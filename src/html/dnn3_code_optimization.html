<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Kaldi: Optimization in the &quot;nnet3&quot; setup</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 <td id="projectlogo"><a href="http://kaldi-asr.org/"><img alt="Logo" src="KaldiTextAndLogoSmall.png"/ style="padding: 3px 5px 1px 5px"></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname" style="display:none">Kaldi
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief" style="display:none"></div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dnn3_code_optimization.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Optimization in the "nnet3" setup </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="dnn3_code_optimization_intro"></a>
Introduction</h1>
<p>This page covers the code-optimization process in the "nnet3" setup, in which we modify the sequence of commands stored in the <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html">NnetComputation</a> object in order to make the execution more efficient.</p>
<ul>
<li>Previous: <a class="el" href="dnn3_code_compilation.html">Compilation in the "nnet3" setup</a></li>
<li>Up: <a class="el" href="dnn3.html">The "nnet3" setup</a></li>
</ul>
<h1><a class="anchor" id="dnn3_optimize_overview"></a>
Overview of optimization</h1>
<p>The optimization process is something that happens after compilation. It consists of modifying the <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html">NnetComputation</a> to make it more efficient. From the point of view of the user it is just a single function call: </p><pre class="fragment">void Optimize(const NnetOptimizeConfig &amp;config,
              const Nnet &amp;nnet,
              const ComputationRequest &amp;request,
              NnetComputation *computation);
</pre><p> Internally, this performs various different types of optimizations, which we will go through below. We also discuss code analysis, which is used in the optimization code to help figure out which changes to the code are permissible; and code checking.</p>
<p>This page is organized as:</p><ul>
<li><a class="el" href="dnn3_code_optimization.html#dnn3_optimize_analysis">Code analysis</a></li>
<li><a class="el" href="dnn3_code_optimization.html#dnn3_optimize_checking">Checking the computation</a></li>
<li><a class="el" href="dnn3_code_optimization.html#dnn3_optimize_optimization">Optimization</a></li>
</ul>
<h1><a class="anchor" id="dnn3_optimize_analysis"></a>
Code analysis</h1>
<p>As mentioned, we have in <a class="el" href="nnet-analyze_8h.html" title="This file contains utilities for analyzing and checking computations, which are used in the optimizat...">nnet-analyze.h</a> various utilities for analyzing code. We defined for a convenience a struct <a class="el" href="structkaldi_1_1nnet3_1_1Analyzer.html" title="This struct exists to set up various pieces of analysis; it helps avoid the repetition of code where ...">Analyzer</a> which runs all this analysis on some compiled code: </p><pre class="fragment">struct Analyzer {
  ComputationVariables variables;
  std::vector&lt;CommandAttributes&gt; command_attributes;
  std::vector&lt;std::vector&lt;Access&gt; &gt; variable_accesses;
  std::vector&lt;MatrixAccesses&gt; matrix_accesses;
  void Init(const Nnet &amp;nnet, const NnetComputation &amp;computation);
};
</pre><p> The Init function sets up its members: </p><pre class="fragment">void Analyzer::Init(const Nnet &amp;nnet, const NnetComputation &amp;computation) {
  variables.Init(computation);
  ComputeCommandAttributes(nnet, computation, variables, &amp;command_attributes);
  ComputeVariableAccesses(variables, command_attributes, &amp;variable_accesses);
  ComputeMatrixAccesses(nnet, computation, variables, command_attributes,
                        &amp;matrix_accesses);
}
</pre><p> There are really four function calls here, because the constructor of member "variables" sets up the member of type <a class="el" href="classkaldi_1_1nnet3_1_1ComputationVariables.html" title="This class relates the matrices and sub-matrices in the computation to imaginary &quot;variables&quot;, such that we can think of the operations as operating on sets of individual variables, and we can then do analysis that lets us do optimization. ">ComputationVariables</a>.</p>
<h2><a class="anchor" id="dnn3_optimize_analysis_variables"></a>
Computation variables</h2>
<p>In order to analyze the computation, it is helpful to break it down into actions on individual variables. If efficiency were not an issue, we could do the analysis at the level of individual elements of a matrix, declaring these to be the variables. However, for now we do the analysis at a slightly coarser-grained level, consisting of column-ranges of matrices. We choose the coarsest set of row ranges such that the column-ranges of all the submatrices can be expressed exactly as a union of these column ranges. Class <a class="el" href="classkaldi_1_1nnet3_1_1ComputationVariables.html" title="This class relates the matrices and sub-matrices in the computation to imaginary &quot;variables&quot;, such that we can think of the operations as operating on sets of individual variables, and we can then do analysis that lets us do optimization. ">ComputationVariables</a> is responsible for identifying these column ranges and for getting the set of variables associated with a given matrix or sub-matrix.</p>
<p>Note that it is possible that in the future we may decide to do the analysis at a finer level (e.g. individual row of the current variables) which would enable more complete optimization in certain rather specialized circumstances. This would not involve very extensive changes to the code outside of class <a class="el" href="classkaldi_1_1nnet3_1_1ComputationVariables.html" title="This class relates the matrices and sub-matrices in the computation to imaginary &quot;variables&quot;, such that we can think of the operations as operating on sets of individual variables, and we can then do analysis that lets us do optimization. ">ComputationVariables</a>.</p>
<p>A "variable" is a zero-based index that corresponds to one of the variables identified by class <a class="el" href="classkaldi_1_1nnet3_1_1ComputationVariables.html" title="This class relates the matrices and sub-matrices in the computation to imaginary &quot;variables&quot;, such that we can think of the operations as operating on sets of individual variables, and we can then do analysis that lets us do optimization. ">ComputationVariables</a>. The public interface of this class is below: </p><pre class="fragment">class ComputationVariables {
 public:
  void Init(const NnetComputation &amp;computation);

  // This function updates the CommandAttributes object to record an access of
  // type read, write or read-write on the variables that this sub-matrix
  // corresponds to, and also updates the matrices_accessed variable by adding
  // the number of the underlying matrix.
  void RecordAccessForSubmatrix(
      int32 submatrix_index,
      AccessType access_type,
      CommandAttributes *ca) const;
  // Appends to variables_indexes the list of variables corresponding to a
  // matrix index.
  void AppendVariablesForMatrix(
      int32 matrix_index,
      std::vector&lt;int32&gt; *variable_indexes) const;
  int32 NumVariables() const { return num_variables_; }
  int32 GetMatrixForVariable(int32 variable) const;

 private:
   ...
};
</pre><p> The <a class="el" href="classkaldi_1_1nnet3_1_1ComputationVariables.html#a1950e6762d3cf829d40382e7c807fc14">RecordAccessForSubmatrix()</a> function won't be very self-explanatory because we haven't yet introduced struct <a class="el" href="structkaldi_1_1nnet3_1_1CommandAttributes.html">CommandAttributes</a>. We'll say more about it below.</p>
<h2><a class="anchor" id="dnn3_optimize_analysis_attributes"></a>
Command attributes</h2>
<p>Struct <a class="el" href="structkaldi_1_1nnet3_1_1CommandAttributes.html">CommandAttributes</a> records which variables are read and which variables written, and also which matrices are read and written. </p><pre class="fragment">struct CommandAttributes {
  // variables read
  std::vector&lt;int32&gt; variables_read;
  // variables written
  std::vector&lt;int32&gt; variables_written;

  // matrices read
  std::vector&lt;int32&gt; matrices_read;
  // matrices written
  std::vector&lt;int32&gt; matrices_written;

  // true if this command has side effects e.g. on the model (such as
  // Backprop on an updatable component, or StoreStats).
  bool has_side_effects;
  CommandAttributes(): has_side_effects(false) { }
};
</pre><p> Some operations must be considered read/write instead of just read or write. For instance, adding something to a matrix is a read/write operation because the final result depends on what was there previously. In these cases we add a variable (or matrix) to both read and written lists. In addition, a pure-write operation that accesses only <em>some parts</em> of a variable or matrix must be considered a read/write operation on that variable or matrix, because the final value still depends on the contents at the start.</p>
<p>The function <a class="el" href="classkaldi_1_1nnet3_1_1ComputationVariables.html#a1950e6762d3cf829d40382e7c807fc14">ComputationVariables::RecordAccessForSubmatrix()</a> is responsible for updating the <a class="el" href="structkaldi_1_1nnet3_1_1CommandAttributes.html">CommandAttributes</a> variable for commands; it is declared as follows. </p><pre class="fragment">  void RecordAccessForSubmatrix(
      int32 submatrix_index,
      AccessType access_type,
      CommandAttributes *ca) const;
</pre><p> where <code>AccessType</code> is an enum that can take values <code>kReadAccess</code>, <code>kWriteAccess</code> and <code>kReadWriteAccess</code>.</p>
<h2><a class="anchor" id="dnn3_optimize_analysis_attributes_computing"></a>
Computing the command attributes</h2>
<p>After initializing the <a class="el" href="classkaldi_1_1nnet3_1_1ComputationVariables.html" title="This class relates the matrices and sub-matrices in the computation to imaginary &quot;variables&quot;, such that we can think of the operations as operating on sets of individual variables, and we can then do analysis that lets us do optimization. ">ComputationVariables</a> object, the next stage in analysis of a computation is to obtain a vector of <a class="el" href="structkaldi_1_1nnet3_1_1CommandAttributes.html">CommandAttributes</a>, one for each command in the computation. The function <a class="el" href="namespacekaldi_1_1nnet3.html#aa02a576b6e9aa0977f3eb52471742b85">ComputeCommandAttributes()</a> is responsible for this. This function is mostly a big switch statement, and we show the first part of it in order to give the reader some idea what is going on: </p><pre class="fragment">void ComputeCommandAttributes(
    const Nnet &amp;nnet,
    const NnetComputation &amp;computation,
    const ComputationVariables &amp;vars,
    std::vector&lt;CommandAttributes&gt; *attributes) {
  int32 num_commands = computation.commands.size();
  attributes-&gt;clear();
  attributes-&gt;resize(num_commands);
  for (int32 command_index = 0; command_index &lt; num_commands; command_index++) {
    const NnetComputation::Command &amp;c = computation.commands[command_index];
    CommandAttributes &amp;attr = (*attributes)[command_index];
    switch (c.command_type) {
      case NnetComputation::kAllocMatrixZeroed:
        vars.AppendVariablesForMatrix(c.arg1, &amp;attr.variables_written);
        break;
      case NnetComputation::kAllocMatrixUndefined: // nothing is written here.
        break;
      case NnetComputation::kDeallocMatrix: // ditto.
        break;
      case NnetComputation::kPropagate:
        vars.RecordAccessForSubmatrix(c.arg3, kReadAccess, &amp;attr);
        if (nnet.GetComponent(c.arg1)-&gt;Properties() &amp; kPropagateAdds)
          vars.RecordAccessForSubmatrix(c.arg4, kReadWriteAccess, &amp;attr);
        else
          vars.RecordAccessForSubmatrix(c.arg4, kWriteAccess, &amp;attr);
        break;
        ...
</pre><h2><a class="anchor" id="dnn3_optimize_analysis_variable_accesses"></a>
Computing the variable accesses</h2>
<p>The next stage in analysis is to compute the variable accesses. This takes the information we stored in the <a class="el" href="structkaldi_1_1nnet3_1_1CommandAttributes.html">CommandAttributes</a>, and list it per variable We define a struct <a class="el" href="structkaldi_1_1nnet3_1_1Access.html">Access</a> as: </p><pre class="fragment">struct Access {
  int32 command_index;
  AccessType access_type;
};
</pre><p> where AccessType is an enumeration value mentioned above. The accesses to any variable will be stored as a <code>std::vector&lt;Access&gt;</code>, and function that computes the accesses for all variables is declared as follows: </p><pre class="fragment">void ComputeVariableAccesses(
    const ComputationVariables &amp;variables,
    const std::vector&lt;CommandAttributes&gt; &amp;command_attributes,
    std::vector&lt;std::vector&lt;Access&gt; &gt; *variable_accesses);
</pre><p> The output <code>variable_accesses</code> is a vector of length (the number of variables), and then a list sorted by command index. There will be only one access per command, as we consolidate them- for example, a combination of a read and write access would be consolidated into a single <code>kReadWrite</code> access.</p>
<h2><a class="anchor" id="dnn3_optimize_analysis_variable_matrix"></a>
Computing the matrix accesses</h2>
<p>Struct <a class="el" href="structkaldi_1_1nnet3_1_1MatrixAccesses.html">MatrixAccesses</a> stores all the information we record for a single matrix, relating to how it is allocated and accessed: </p><pre class="fragment">struct MatrixAccesses {
  // Index of the command that allocates the matrix, or -1 if the command
  // doesn't exist (e.g. it is an input).
  int32 allocate_command;
  // Index of the command that deallocates the matrix, or -1 if never gets
  // deallocated (e.g. it is an output).
  int32 deallocate_command;
  // Records the indexes of commands that access the matrix, and the type
  // (read, read/write, write).  It will be sorted on command index with only
  // one record per command.  Note: a write to only a part of the matrix
  // (i.e. a submatrix that isn't the whole thing) will be recorded as an
  // access of type read/write.
  std::vector&lt;Access&gt; accesses;
  // true if this matrix is an input to the computation.
  bool is_input;
  // true if this matrix is an output of the computation.
  bool is_output;
  MatrixAccesses(): allocate_command(-1), deallocate_command(-1),
                    is_input(false), is_output(false) { }
};
</pre><p> You can see that we store more information than we do for the variables (i.e. more than just the <code>std::vector&lt;Access&gt;</code>). This is so that we can check whether the matrix is being allocated and deallocated appropriately.</p>
<p>The matrix accesses are computed by the function <a class="el" href="namespacekaldi_1_1nnet3.html#a2f107eabc73f1b70436ed117375778c1" title="This function organizes information in the CommandAttributes in a way that is convenient to access pe...">ComputeMatrixAccesses()</a>.</p>
<h1><a class="anchor" id="dnn3_optimize_checking"></a>
Checking the computation</h1>
<p>After performing the analysis as described in the previous section, we can check the computation using class <a class="el" href="classkaldi_1_1nnet3_1_1ComputationChecker.html">ComputationChecker</a>. We list some of its code below; a glance at some of the names of private function members will indicate the kind of checks it is performing. </p><pre class="fragment">class ComputationChecker {
 public:
  ComputationChecker(const CheckComputationConfig &amp;config,
                     const Nnet &amp;nnet,
                     const ComputationRequest &amp;request,
                     const NnetComputation &amp;computation);
  void Check();
 private:
  // various dimension consistency checks and checks on properties.
  void CheckComputationIndexes() const;
  // make sure Propagate comes before kNoOpMarker and Backprop comes after it,
  // and that the value of forward_computation_end matches the position of
  // kNoOpMarker.
  void CheckComputationOrder() const;
  // checks for a situation where an undefined variable is read.
  void CheckComputationUndefined() const;
  // checks that all writes are done before reads.  details with implementation.
  void CheckComputationRewrite() const;
  // check matrix accesses make sense.
  void CheckComputationMatrixAccesses() const;
  ...
</pre><p> This checking code exists mainly to detect bugs in the compilation and optimization code.</p>
<h1><a class="anchor" id="dnn3_optimize_optimization"></a>
Optimization</h1>
<p>The optimization code has an options class that enables the user to turn off various of the specific optimizations it does. This is intended to help in debugging. The options class has a variable for each individual optimization: </p><pre class="fragment">struct NnetOptimizeConfig {
  bool optimize;  // setting this false disallow all optimization.
  bool propagate_in_place;
  bool backprop_in_place;
  bool remove_assignments;
  bool initialize_undefined;
  bool move_sizing_commands;
  ...
};
</pre><p> The top-level call to the optimization code is just a function call. We show some partial code for this function below: </p><pre class="fragment">void Optimize(const NnetOptimizeConfig &amp;config,
              const Nnet &amp;nnet,
              const ComputationRequest &amp;request,
              NnetComputation *computation) {
  if (!config.optimize)
    return;
  bool changed = true;
  while (changed) {
    changed = false;
    VariableMergingOptimizer opt(config, nnet, request, computation);
    if (opt.MergeVariables())
      changed = true;
  }
  if (config.initialize_undefined)
    RemoveUnnecessaryZeroing(nnet, computation);

  if (config.move_sizing_commands)
    MoveSizingCommands(nnet, computation);
}
</pre><p> The <a class="el" href="classkaldi_1_1nnet3_1_1VariableMergingOptimizer.html" title="This class is responsible for merging matrices, although you probably want to access it via the the f...">VariableMergingOptimizer</a> is a class that is responsible for merging variables together; it detects situations where there are two separate matrices that can be replaced with a single matrix.</p>
<ul>
<li>Up: <a class="el" href="dnn3.html">The "nnet3" setup</a></li>
<li>Previous: <a class="el" href="dnn3_code_compilation.html">Compilation in the "nnet3" setup</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Kaldi</a></li><li class="navelem"><a class="el" href="dnn.html">Deep Neural Networks in Kaldi</a></li><li class="navelem"><a class="el" href="dnn3.html">The &quot;nnet3&quot; setup</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
