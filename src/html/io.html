<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Kaldi: Kaldi I/O mechanisms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 <td id="projectlogo"><a href="http://kaldi-asr.org/"><img alt="Logo" src="KaldiTextAndLogoSmall.png"/ style="padding: 3px 5px 1px 5px"></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname" style="display:none">Kaldi
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief" style="display:none"></div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('io.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Kaldi I/O mechanisms </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page gives an overview of input-output mechanisms in Kaldi.</p>
<p>This section of the documentation is oriented towards the code-level mechanisms for I/O; for documentation more oriented towards the command-line, see <a class="el" href="io_tut.html">Kaldi I/O from a command-line perspective.</a>.</p>
<h1><a class="anchor" id="io_sec_style"></a>
The input/output style of Kaldi classes</h1>
<p>Classes defined in Kaldi have a uniform interface for I/O. The standard interface is illustrated here: </p><div class="fragment"><div class="line"><span class="keyword">class </span>SomeKaldiClass {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   <span class="keywordtype">void</span> Read(std::istream &amp;is, <span class="keywordtype">bool</span> binary);</div><div class="line">   <span class="keywordtype">void</span> Write(std::ostream &amp;os, <span class="keywordtype">bool</span> binary) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p> Notice that these return void; errors are indicated via exceptions (see <a class="el" href="error.html">Kaldi logging and error-reporting</a>). The boolean "binary" argument indicates whether the object should be written (or read) as binary data or text data. The calling code must know whether we want the object to be written or read in binary or text form (see <a class="el" href="io.html#io_sec_files">How Kaldi objects are stored in files</a> for how it knows this in the case of reading). Note that this "binary" variable is not necessarily the same as the binary or text mode the file is opened with (on Windows); see <a class="el" href="io.html#io_sec_windows">How the binary/text mode relates to the file open mode</a> for more explanation.</p>
<p>The Read and Write functions may have additional optional arguments. A common case is to have a Read function of the form: </p><div class="fragment"><div class="line"><span class="keyword">class </span>SomeKaldiClass {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> Read(std::istream &amp;is, <span class="keywordtype">bool</span> binary, <span class="keywordtype">bool</span> add = <span class="keyword">false</span>);</div><div class="line">};</div></div><!-- fragment --><p> If add==true, the Read function would add whatever is on disk (e.g. statistics) to the current class's contents, if the class is not currently empty.</p>
<h1><a class="anchor" id="io_sec_basic"></a>
Input/output mechanisms for fundamental types and STL types</h1>
<p>See <a class="el" href="group__io__funcs__basic.html">"Low-level I/O functions"</a> for a list of functions involved in this. We have provided thse functions to make it easier to read and write fundamental types; they are mostly called from the Read and Write functions of Kaldi classes. The Kaldi classes are under no obligation to use these functions, as long as they ensure that their Read function can read the data that their Write function produces.</p>
<p>The most important functions in this category are <a class="el" href="group__io__funcs__basic.html#ga1bd1af0ef712b76f2332febcec8d095a" title="ReadBasicType is the name of the read function for bool, integer types, and floating-point types...">ReadBasicType()</a> and <a class="el" href="group__io__funcs__basic.html#ga108506a9aabafd9006926aa1b47617da" title="WriteBasicType is the name of the write function for bool, integer types, and floating-point types...">WriteBasicType()</a>; these are templates that cover bool, float, double, and integer types. An example of using these in Read and Write functions is: </p><div class="fragment"><div class="line"><span class="comment">// we suppose that class_member_ is of type int32.</span></div><div class="line"><span class="keywordtype">void</span> SomeKaldiClass::Read(std::istream &amp;is, <span class="keywordtype">bool</span> binary) {</div><div class="line">  <a class="code" href="group__io__funcs__basic.html#ga1bd1af0ef712b76f2332febcec8d095a">ReadBasicType</a>(is, binary, &amp;class_member_);</div><div class="line">}</div><div class="line"><span class="keywordtype">void</span> SomeKaldiClass::Write(std::ostream &amp;os, <span class="keywordtype">bool</span> binary)<span class="keyword"> const </span>{</div><div class="line">  <a class="code" href="group__io__funcs__basic.html#ga108506a9aabafd9006926aa1b47617da">WriteBasicType</a>(os, binary, class_member_);</div><div class="line">}</div></div><!-- fragment --><p> We have assumed that <code>class_member_</code> is of type int32, which is a type of known size. Using types like int with these functions is not safe. In binary mode, these functions actually write a character that encodes the size and signedness of integer types, and the read will fail if it doesn't match. We could have decided to attempt to convert them automatically, but we didn't; currently, you have to use integer types of known size in I/O (int32 is recommended for "normal" use). Floating-point types, on the other hand, are automatically converted. This is for ease of debugging, so you can compile with <code>-DKALDI_DOUBLE_PRECISION</code> and still read your binary files that were written without that option. Our I/O routines have no byte swapping; if this is a problem for you, use the text formats.</p>
<p>There are also the <a class="el" href="group__io__funcs__basic.html#ga99e4557f845a9c1e3202ab136226a980" title="Function for writing STL vectors of integer types. ">WriteIntegerVector()</a> and <a class="el" href="group__io__funcs__basic.html#ga0e0391048fe585c1e97b4d65d59d32bc" title="Function for reading STL vector of integer types. ">ReadIntegerVector()</a> templated functions. These are in the same style as the <a class="el" href="group__io__funcs__basic.html#ga108506a9aabafd9006926aa1b47617da" title="WriteBasicType is the name of the write function for bool, integer types, and floating-point types...">WriteBasicType()</a> and <a class="el" href="group__io__funcs__basic.html#ga1bd1af0ef712b76f2332febcec8d095a" title="ReadBasicType is the name of the read function for bool, integer types, and floating-point types...">ReadBasicType()</a> functions, but work for <code>std::vector&lt;I&gt;</code>, where I is some integer type (again, its size should be known at compile time, e.g. int32).</p>
<p>Some other important low-level I/O functions are; </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__io__funcs__basic.html#gacbf9367cd910befefa0bc98055979bea">ReadToken</a>(std::istream &amp;is, <span class="keywordtype">bool</span> binary, std::string *token);</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__io__funcs__basic.html#ga87f1638ef3c0a3ee117178b202c2d02a">WriteToken</a>(std::ostream &amp;os, <span class="keywordtype">bool</span> binary, <span class="keyword">const</span> std::string &amp; token);</div></div><!-- fragment --><p> A token must be a nonempty string with no spaces, typically in practice an XML-looking string like "&lt;SomeKaldiClass&gt;" or "&lt;SomeClassMemberName&gt;" or "&lt;/SomeKaldiClass&gt;". These functions do what they look like they would do. For convenience, we also provide <a class="el" href="group__io__funcs__basic.html#ga4c7a80f758e878578e78b667f62463a5" title="ExpectToken tries to read in the given token, and throws an exception on failure. ...">ExpectToken()</a>, which is like <a class="el" href="group__io__funcs__basic.html#gacbf9367cd910befefa0bc98055979bea" title="ReadToken gets the next token and puts it in str (exception on failure). ">ReadToken()</a> except you give it the string you expect (and it will throw an exception if it doesn't get it). Typical lines of code invoking these are: </p><div class="fragment"><div class="line"><span class="comment">// in writing code:</span></div><div class="line"><a class="code" href="group__io__funcs__basic.html#ga87f1638ef3c0a3ee117178b202c2d02a">WriteToken</a>(os, binary, <span class="stringliteral">&quot;&lt;MyClassName&gt;&quot;</span>);</div><div class="line"><span class="comment">// in reading code:</span></div><div class="line"><a class="code" href="group__io__funcs__basic.html#ga4c7a80f758e878578e78b667f62463a5">ExpectToken</a>(is, binary, <span class="stringliteral">&quot;&lt;MyClassName&gt;&quot;</span>);</div><div class="line"><span class="comment">// or, if a class has multiple forms:</span></div><div class="line">std::string token;</div><div class="line"><a class="code" href="group__io__funcs__basic.html#gacbf9367cd910befefa0bc98055979bea">ReadToken</a>(is, binary, &amp;token);</div><div class="line"><span class="keywordflow">if</span>(token == <span class="stringliteral">&quot;&lt;OptionA&gt;&quot;</span>) { ... }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>(token == <span class="stringliteral">&quot;&lt;OptionB&gt;&quot;</span>) { ... }</div><div class="line">...</div></div><!-- fragment --><p> There are also the WritePretty() and <a class="el" href="group__io__funcs__basic.html#ga607f811e0e5f7cc1e29940db9b4a2985" title="ExpectPretty attempts to read the text in &quot;token&quot;, but only in non-binary mode. ">ExpectPretty()</a> functions. These are less frequently used, and they behave like the corresponding Token functions except that they only actually read and write in text mode, and they accept arbitrary strings (i.e. they allow spaces); the ReadPretty function also accepts input that has differs in whitespace versus what was expected. The Read functions in Kaldi classes never check for end of file, but are expected to read until the end of where the Write function wrote to (in text mode, leaving some whitespace unread doesn't matter). This is so that multiple Kaldi objects can be put in the same file, and also allows the archive concept (see <a class="el" href="io.html#io_sec_archive">The Kaldi archive format</a>) to work.</p>
<h1><a class="anchor" id="io_sec_files"></a>
How Kaldi objects are stored in files</h1>
<p>As we have seen above, the Kaldi reading code needs to know whether it is reading in text or binary mode, and we don't want the user to have to keep track of whether a given file is text or binary. For this reason, files that contain Kaldi objects need to announce whether they contain binary or text data. A binary Kaldi file will start with the string "\0B"; since text files can't contain "\0", they don't need a header. If you opened a file using standard C++ mechanisms (and you won't normally be doing this, see <a class="el" href="io.html#io_sec_opening">How to open files in Kaldi</a>), you would have to take care of this header before doing anything. You could do this with the functions <a class="el" href="namespacekaldi.html#a527dbcafdb9efac657f18943cdf1a217" title="InitKaldiOutputStream initializes an opened stream for writing by writing an optional binary header a...">InitKaldiOutputStream()</a> (this also sets the stream precision), and <a class="el" href="namespacekaldi.html#a73789daaacd32961040ff917e9c5bc59" title="Initialize an opened stream for reading by detecting the binary header and. ">InitKaldiInputStream()</a>.</p>
<h1><a class="anchor" id="io_sec_opening"></a>
How to open files in Kaldi</h1>
<p>Suppose you want to load or save a Kaldi object from/to disk, and suppose it is something like speech model (but not something that you need many of, like speech features; for that, see <a class="el" href="io.html#io_sec_tables">The Table concept</a>). You will typically use the <a class="el" href="classkaldi_1_1Input.html">Input</a> and <a class="el" href="classkaldi_1_1Output.html">Output</a> classes. An example is: </p><div class="fragment"><div class="line">{ <span class="comment">// input.</span></div><div class="line">  <span class="keywordtype">bool</span> binary_in;</div><div class="line">  Input ki(some_rxfilename, &amp;binary_in);</div><div class="line">  my_object.Read(ki.Stream(), binary_in);</div><div class="line">  <span class="comment">// you can have more than one object in a file:</span></div><div class="line">  my_other_object.Read(ki.Stream(), binary_in);</div><div class="line">}</div><div class="line"><span class="comment">// output.  note, &quot;binary&quot; is probably a command-line option.</span></div><div class="line">{</div><div class="line">  Output ko(some_wxfilename, binary);</div><div class="line">  my_object.Write(ko.Stream(), binary);</div><div class="line">}</div></div><!-- fragment --><p> The purpose of the braces is to make the <a class="el" href="classkaldi_1_1Input.html">Input</a> and <a class="el" href="classkaldi_1_1Output.html">Output</a> objects go out of scope as soon as we're done, so the file gets closed immediately. This might seem a bit pointless (why not use a normal C++ stream?). The reason is so we can support various extended types of filename. It also makes handling errors a bit easier (the <a class="el" href="classkaldi_1_1Input.html">Input</a> and <a class="el" href="classkaldi_1_1Output.html">Output</a> classes will print an informative error message and throw an exception on error). Notice the filenames have "rxfilename" and "wxfilename" in them. We use these types of names a lot, and they are supposed to remind the coder that these are extended filenames. We describe these entities in the next section.</p>
<p>The <a class="el" href="classkaldi_1_1Input.html">Input</a> and <a class="el" href="classkaldi_1_1Output.html">Output</a> classes have a slightly richer interface than used in the example code above. You can open them with Open(), and you can call Close() rather than just letting them go out of scope. These functions return boolean status values rather than throwing exceptions on error the way the constructors and destructors will. The Open() functions (and the constructors) can also be called in such a way that they don't handle the Kaldi binary header, in case you need to read or write non-Kaldi objects. You probably won't need any of this extra functionality.</p>
<p>See <a class="el" href="group__io__group.html">"Classes for opening streams"</a> for classes and functions related to <a class="el" href="classkaldi_1_1Input.html">Input</a> and <a class="el" href="classkaldi_1_1Output.html">Output</a>, and to rxfilenames and wxfilenames (next section).</p>
<h1><a class="anchor" id="io_sec_xfilename"></a>
Extended filenames: rxfilenames and wxfilenames</h1>
<p>The words "rxfilename" and "wxfilename" are not classes; they are descriptors that usually appear in variable names, and they indicate the following:</p><ul>
<li>an rxfilename is a string that is to be interpreted by the <a class="el" href="classkaldi_1_1Input.html">Input</a> class as an extended filename for reading</li>
<li>a wxfilename is a string that is to be interpreted by the <a class="el" href="classkaldi_1_1Output.html">Output</a> class as an extended filename for writing</li>
</ul>
<p>The types of rxfilename are as follows:</p>
<ul>
<li>"-" or "" means the standard input</li>
<li>"some command |" means an input piped command, i.e. we strip off the "|" and give the rest of the string to the shell via popen().</li>
<li>"/some/filename:12345" means an offset into a file, i.e. we open the file and seek to position 12345.</li>
<li>"/some/filename" ... anything not matching the patterns above is treated as a normal filename (however, some obviously wrong things will be recognized as errors before attempting to open them).</li>
</ul>
<p>You can find out what type an rxfilename is using <a class="el" href="group__io__group.html#gaeec96e3c4cadb53222707c4b608fc7e6" title="ClassifyRxfilenames interprets filenames for reading as follows: ">ClassifyRxfilename()</a>, but this typically won't be necessary.</p>
<p>The types of wxfilename are as follows:</p><ul>
<li>"-" or "" means the standard input</li>
<li>"| some command" means an output piped command, i.e. we strip off the "|" and give the rest of the string to the shell via popen().</li>
<li>"/some/filename" ... anything not matching the patterns above is treated as a normal filename (again, barring obvious errors).</li>
</ul>
<p>Again, <a class="el" href="group__io__group.html#ga9b921175f3d897df5d71b0e28bb59650" title="ClassifyWxfilename interprets filenames as follows: ">ClassifyWxfilename()</a> tells you the type of a filename.</p>
<h1><a class="anchor" id="io_sec_tables"></a>
The Table concept</h1>
<p>A Table is a concept rather than actual C++ class. It consists of a collection of objects of some known type, indexed by strings. These strings must be tokens (a token is defined as a non-empty string without whitespaces). Typical examples of Tables include:</p>
<ul>
<li>A collection of feature files (represented as <a class="el" href="classkaldi_1_1Matrix.html">Matrix&lt;float&gt;</a>) indexed by utterance id</li>
<li>A collection of transcriptions (represented as std::vector&lt;int32&gt;), indexed by utterance id</li>
<li>A collection of Constrained MLLR transforms (represented as <a class="el" href="classkaldi_1_1Matrix.html">Matrix&lt;float&gt;</a>), indexed by speaker id.</li>
</ul>
<p>We will deal with these types of tables in more detail on the page <a class="el" href="table_examples.html">Types of data that we write as tables</a>; here we just explain the general principles and the internal mechanisms. A Table can exist on disk (or indeed, in a pipe) in two possible formats: a script file, or an archive (see below, <a class="el" href="io.html#io_sec_scp">The Kaldi script-file format</a> and <a class="el" href="io.html#io_sec_archive">The Kaldi archive format</a>). For a list of classes and types that relate to Tables, see <a class="el" href="group__table__group.html">"Table types and related functions"</a>.</p>
<p>A Table can be accessed in three ways: using a <a class="el" href="classkaldi_1_1TableWriter.html" title="A templated class for writing objects to an archive or script file; see The Table concept...">TableWriter</a>, a <a class="el" href="classkaldi_1_1SequentialTableReader.html" title="A templated class for reading objects sequentially from an archive or script file; see The Table conc...">SequentialTableReader</a>, and a <a class="el" href="classkaldi_1_1RandomAccessTableReader.html" title="Allows random access to a collection of objects in an archive or script file; see The Table concept...">RandomAccessTableReader</a> (there is also <a class="el" href="classkaldi_1_1RandomAccessTableReaderMapped.html" title="This class is for when you are reading something in random access, but it may actually be stored per-...">RandomAccessTableReaderMapped</a>, which is a special case we will introduce later). These are all templates; they are templated not on the object in the table, but on a Holder type (see below, <a class="el" href="io.html#io_sec_holders">Holders as helpers to Table classes</a>) that tells the Table code how to read and write that type of object. To open a Table type, you must provide a string called a wspecifier or rspecifier (see below, <a class="el" href="io.html#io_sec_specifiers">Specifying Table formats: wspecifiers and rspecifiers</a>) that tells the Table code how the table is stored on disk and gives it various other directives. We illustrate this with some example code. This code reads features, linearly transforms them and writes them out. </p><div class="fragment"><div class="line">std::string feature_rspecifier = <span class="stringliteral">&quot;scp:/tmp/my_orig_features.scp&quot;</span>,</div><div class="line">   transform_rspecifier = <span class="stringliteral">&quot;ark:/tmp/transforms.ark&quot;</span>,</div><div class="line">   feature_wspecifier = <span class="stringliteral">&quot;ark,t:/tmp/new_features.ark&quot;</span>;</div><div class="line"><span class="comment">// there are actually more convenient typedefs for the types below,</span></div><div class="line"><span class="comment">// e.g. BaseFloatMatrixWriter, SequentialBaseFloatMatrixReader, etc.</span></div><div class="line">TableWriter&lt;BaseFloatMatrixHolder&gt; feature_writer(feature_wspecifier);</div><div class="line">SequentialTableReader&lt;BaseFloatMatrixHolder&gt; feature_reader(feature_rspecifier);</div><div class="line">RandomAccessTableReader&lt;BaseFloatMatrixHolder&gt; transform_reader(transform_rspecifier);</div><div class="line"><span class="keywordflow">for</span>(; !feature_reader.Done(); feature_reader.Next()) {</div><div class="line">   std::string utt = feature_reader.Key();</div><div class="line">   <span class="keywordflow">if</span>(transform_reader.HasKey(utt)) {</div><div class="line">      Matrix&lt;BaseFloat&gt; new_feats(feature_reader.Value());</div><div class="line">      ApplyFmllrTransform(new_feats, transform_reader.Value(utt));</div><div class="line">      feature_writer.Write(utt, new_feats);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p> The nice thing about this setup is that the code that accesses the tables can treat them as generic maps or lists. The format of the data and other aspects of the reading process (e.g., its error tolerance) can be controlled by options in the rspecifiers and wspecifiers and does not have to be handled by the calling code; in the example above, the option ",t" tells it to write the data in text form.</p>
<p>The Platonic ideal of a Table would probably be a map from a string to the object. However, as long as we're not doing random access on a particular table, the code will not complain if it contains duplicate entries for a particular string (i.e. for writing and sequential access, it behaves more like a list of pairs).</p>
<p>For a list of typedefs corresponding to Table types to read and write specific types, see <a class="el" href="group__table__types.html">"Specific Table types"</a>.</p>
<h1><a class="anchor" id="io_sec_scp"></a>
The Kaldi script-file format</h1>
<p>A script file (perhaps slightly misnamed) is a text file where each line will typically contain something like: </p><pre class="fragment">  some_string_identifier /some/filename</pre><p> Another valid line in a script file would be: </p><pre class="fragment">  utt_id_01002 gunzip -c /usr/data/file_010001.wav.gz |</pre><p> The general form of these lines is: </p><pre class="fragment">  &lt;key&gt; &lt;rxfilename&gt;</pre><h2><a class="anchor" id="io_sec_scp_range"></a>
Ranges in script-file lines (for taking sub-parts of matrices)</h2>
<p>We also allow an optional 'range-specifier' to appear after the rxfilename; this is useful for representing parts of matrices, such as row ranges. Ranges are currently not supported for any data types other than matrices. For example, we can express a row range of a matrix as follows: </p><pre class="fragment">  utt_id_01002 foo.ark:89142[0:51]</pre><p> which means rows 0 through 51 (inclusive) of the matrix. Both row and column ranges may be expressed, e.g. </p><pre class="fragment">  utt_id_01002 foo.ark:89142[0:51,89:100]</pre><p> and if you just want to express a column range, you can leave the row-range blank, as follows: </p><pre class="fragment">  utt_id_01002 foo.ark:89142[,89:100]</pre><h2><a class="anchor" id="io_sec_scp_details"></a>
How Kaldi processes lines of scp files</h2>
<p>When reading a line of script file, Kaldi will trim off leading and trailing whitespace, and then split the line on the first region of whitespace. The first part becomes the key into the table (e.g. the utterance id, in this case "utt_id_01001"), and the second part (after stripping off the optional range-specifier) becomes the xfilename (by which we mean an wxfilename or rxfilename, in this case "gunzip -c /usr/data/file_010001.wav.gz |"). An empty line or an empty xfilename is not allowed. A script file may be valid for reading or writing or both, depending whether the xfilenames are valid rxfilenames, or wxfilenames, or both.</p>
<p>Note: once the optional ranges are stripped off, the (r,x)filenames that appear on lines of script files may generally be given to any Kaldi program in the same way you'd give a filename. This is even true of rspecifiers that contain byte offsets, like foo.ark:8432. The byte offsets will point to the beginning of the data of the object (not to the key-value that precedes the data in the archive). For binary data, the byte offset points to the "\0B" that precedes the object; this allows the reading code to ascertain that the data is binary before it reads the object.</p>
<h1><a class="anchor" id="io_sec_archive"></a>
The Kaldi archive format</h1>
<p>The Kaldi archive format is quite simple. First recall that a token is defined as a whitespace-free string. The archive format could be described as: </p><pre class="fragment">     token1 [something]token2 [something]token3 [something] ....</pre><p> We can describe this as zero or more repetitions of: (a token; then a space character; then the result of calling the Write function of the Holder). Recall that the Holder is an object that tells the Table code how to read or write something.</p>
<p>When writing Kaldi objects, the [something] written by the Holder will constist of the binary-mode header (if binary), and then the result of calling the Write function of the object. When writing non-Kaldi objects that are simple (like int32 or float or vector&lt;int32&gt;), the Holder classes that we write generally ensure that in the text format, the [something] is a newline-terminated string. That way, the archive has a nice one-line-per-entry format that looks superfically like a script file, for instance: </p><pre class="fragment">    utt_id_1 5
    utt_id_2 7
    ...</pre><p> is the text archive format we use for storing integers.</p>
<p>The archive format is such that you can concatenate archives together and they will still be a valid archive (assuming they hold the same type of object). The format has been designed to be pipe-friendly, i.e. you can put an archive in a pipe and the program reading it won't have to wait till the end of the pipe before it can process the data. For efficient random access into archives it's possible to simultaneously write an archive to disk together with a script file that contains offsets into the archive. For this, see the next section.</p>
<h1><a class="anchor" id="io_sec_specifiers"></a>
Specifying Table formats: wspecifiers and rspecifiers</h1>
<p>The Table classes require a string that is passed to the constructor or to the Open method. This string is called a wspecifier if passed to the <a class="el" href="classkaldi_1_1TableWriter.html" title="A templated class for writing objects to an archive or script file; see The Table concept...">TableWriter</a> class, or a rspecifier if passed to the <a class="el" href="classkaldi_1_1RandomAccessTableReader.html" title="Allows random access to a collection of objects in an archive or script file; see The Table concept...">RandomAccessTableReader</a> or <a class="el" href="classkaldi_1_1SequentialTableReader.html" title="A templated class for reading objects sequentially from an archive or script file; see The Table conc...">SequentialTableReader</a> classes. Examples of valid rspecifiers and wspecifiers include: </p><div class="fragment"><div class="line">std::string rspecifier1 = <span class="stringliteral">&quot;scp:data/train.scp&quot;</span>; <span class="comment">// script file.</span></div><div class="line">std::string rspecifier2 = <span class="stringliteral">&quot;ark:-&quot;</span>; <span class="comment">// archive read from stdin.</span></div><div class="line"><span class="comment">// write to a gzipped text archive.</span></div><div class="line">std::string wspecifier1 = <span class="stringliteral">&quot;ark,t:| gzip -c &gt; /some/dir/foo.ark.gz&quot;</span>;</div><div class="line">std::string wspecifier2 = <span class="stringliteral">&quot;ark,scp:data/my.ark,data/my.ark&quot;</span>;</div></div><!-- fragment --><p>Usually, an rspecifier or wspecifier consists of a comma-separated, unordered list of one or two-letter options and one of the strings "ark" and "scp", followed by a colon, followed by an rxfilename or wxfilename respectively. The order of options before the colon doesn't matter.</p>
<h2><a class="anchor" id="io_sec_specifiers_both"></a>
Writing an archive and a script file simultaneously</h2>
<p>There is a special case available for wspecifiers: they can "ark,scp" before the colon, and after the colon, a wxfilename for writing the archive, then a comma, then a wxfilename (for the script file). For example, </p><pre class="fragment">  "ark,scp:/some/dir/foo.ark,/some/dir/foo.scp"</pre><p> This will write an archive, and a script file with lines like "utt_id /somedir/foo.ark:1234" that specify offsets into the archive for more efficient random access. You can then do what you like which the script file, including breaking it up into segments, and it will behave like any other script file. Note that although the order of options before the colon doesn't generally matter, in this particular case the "ark" must come before the "scp"; this is in order to prevent confusion about the order of the two wxfilenames after the colon (the archive always comes first). The wxfilename that specifies the archive should be a normal filename or otherwise the script file that gets written won't be directly readable by Kaldi, but the code doesn't enforce this.</p>
<h2><a class="anchor" id="io_sec_wspecifiers"></a>
Valid options for wspecifiers</h2>
<p>The allowable wspecifier options are:</p><ul>
<li>"b" (binary) means write in binary mode (currently unnecessary as it's always the default).</li>
<li>"t" (text) means write in text mode.</li>
<li>"f" (flush) means flush the stream after each write operation.</li>
<li>"nf" (no-flush) means don't flush the stream after each write operation (would currently be pointless, but calling code can change the default).</li>
<li>"p" means permissive mode, which affects "scp:" wspecifiers where the scp file is missing some entries: the "p" option will cause it to silently not write anything for these files, and report no error.</li>
</ul>
<p>Examples of wspecifiers using a lot of options are </p><pre class="fragment">       "ark,t,f:data/my.ark"
       "ark,scp,t,f:data/my.ark,|gzip -c &gt; data/my.scp.gz"</pre><h2><a class="anchor" id="io_sec_rspecifiers"></a>
Valid options for rspecifiers</h2>
<p>When reading the options below, bear in mind the code that reads archives can never seek in the archive, in case the archive is actually a pipe (and it very often is). If a <a class="el" href="classkaldi_1_1RandomAccessTableReader.html" title="Allows random access to a collection of objects in an archive or script file; see The Table concept...">RandomAccessTableReader</a> is reading an archive, the reading code may have to store many objects in memory just in case they are requested again later, or it may have to seek to the end of an archive while looking for a key that was not actually present in the archive. Some of the options below represent ways to prevent this.</p>
<p>The important rspecifier options are:</p><ul>
<li>"o" (once) is the user's way of asserting to the <a class="el" href="classkaldi_1_1RandomAccessTableReader.html" title="Allows random access to a collection of objects in an archive or script file; see The Table concept...">RandomAccessTableReader</a> code that each key will be queried only once. This stops it from having to keep already-read objects in memory just in case they are needed again.</li>
<li>"p" (permissive) instructs the code to ignore errors and just provide what data it can; invalid data is treated as not existing. In scp files, this means that a query to HasKey() forces the load of the corresponding file, so the code can know to return false if the file is corrupt. In archives, this option stops exceptions from being raised if the archive is corrupted or truncated (it will just stop reading at that point).</li>
<li>"s" (sorted) instructs the code that the keys in an archive being read are in sorted string order. For <a class="el" href="classkaldi_1_1RandomAccessTableReader.html" title="Allows random access to a collection of objects in an archive or script file; see The Table concept...">RandomAccessTableReader</a>, this means that when HasKey() is called for some key not in the archive, it can return false as soon as it encounters a "higher" key; it won't have to read till the end.</li>
<li>"cs" (called-sorted) instructs the code that the calls to HasKey() and Value() will be in sorted string order. Thus, if one of these functions is called for some string, the reading code can discard the objects for lower-numbered keys. This saves memory. In effect, "cs" represents the user's assertion that some other archive that the program may be iterating over, is itself sorted.</li>
</ul>
<p>If the user provides any of these options wrongly, e.g. provides the "s" option for an archive that is not actually sorted, the <a class="el" href="classkaldi_1_1RandomAccessTableReader.html" title="Allows random access to a collection of objects in an archive or script file; see The Table concept...">RandomAccessTableReader</a> code will make a best-effort attempt to detect this error and crash.</p>
<p>The following options are included for symmetry and convenience but are not very useful at the moment.</p><ul>
<li>"no" (not-once) is the opposite of "o" (in current code, this would never have any effect).</li>
<li>"np" (not-permissive) is the opposite of "p" (in current code, this would never have any effect).</li>
<li>"ns" (not-sorted) is the opposite of "s" (in current code, this would never have any effect).</li>
<li>"ncs" (not-called-sorted) is the opposite of "cs" (in current code, this would never have any effect).</li>
<li>"b" (binary) does nothing but is allowed for scripting convenience.</li>
<li>"t" (text) does nothing but is allowed for scripting convenience.</li>
</ul>
<p>Typical examples of rspecifiers using a lot of options are: </p><pre class="fragment">     "ark:o,s,cs:-"
     "scp,p:data/my.scp"</pre><h1><a class="anchor" id="io_sec_holders"></a>
Holders as helpers to Table classes</h1>
<p>As mentioned before, the Table classes i.e. <a class="el" href="classkaldi_1_1TableWriter.html" title="A templated class for writing objects to an archive or script file; see The Table concept...">TableWriter</a>, <a class="el" href="classkaldi_1_1RandomAccessTableReader.html" title="Allows random access to a collection of objects in an archive or script file; see The Table concept...">RandomAccessTableReader</a> and <a class="el" href="classkaldi_1_1SequentialTableReader.html" title="A templated class for reading objects sequentially from an archive or script file; see The Table conc...">SequentialTableReader</a>, are templated on a Holder class. Holder is not an actual class or base class but describes a category of classes, and these have been given names ending in Holder, e.g. <a class="el" href="classkaldi_1_1TokenHolder.html">TokenHolder</a> or <a class="el" href="classkaldi_1_1KaldiObjectHolder.html" title="KaldiObjectHolder works for Kaldi objects that have the &quot;standard&quot; Read and Write functions...">KaldiObjectHolder</a>. (<a class="el" href="classkaldi_1_1KaldiObjectHolder.html" title="KaldiObjectHolder works for Kaldi objects that have the &quot;standard&quot; Read and Write functions...">KaldiObjectHolder</a> is a generic Holder that may be templated on any class satisfying that Kaldi I/O style described in <a class="el" href="io.html#io_sec_style">The input/output style of Kaldi classes</a>). We have written the template class <a class="el" href="classkaldi_1_1GenericHolder.html" title="GenericHolder serves to document the requirements of the Holder interface; it&#39;s not intended to be us...">GenericHolder</a>, which is not intended to be used, in order to document the properties that the Holder classes must satisfy.</p>
<p>The type of the class "held" by the Holder class is a typedef Holder::T (where Holder is the name of the actual Holder class in question). A list of the available holder types may be found in <a class="el" href="group__holders.html">"Holder types"</a>.</p>
<h1><a class="anchor" id="io_sec_windows"></a>
How the binary/text mode relates to the file open mode</h1>
<p>This section is only relevant on the Windows platform. The general rule is that when writing, the file mode will always match the "binary" argument to the Write function; when reading binary data, the file mode will always be binary, but when reading text data, the file mode may be binary or text (thus the text-mode reading functions must always accept the extra '\r' characters that Windows inserts). This is because we don't always know until we open a file, whether its contents are binary or text and so when unsure, we open in binary mode.</p>
<h1><a class="anchor" id="io_sec_bloat"></a>
Avoiding memory bloat when reading archives in random-access mode</h1>
<p>When large archives are read in random access mode by the Table code, there is a potential for memory bloat. This potentially occurs whenever an object of type RandomAccessTableReader&lt;SomeHolder&gt; reads in an archive. The Table code is written so as to first and foremost ensure correctness, so when reading an archive in random access mode, unless you give the Table code some additional information (which we will discuss below), it can never throw away any object it has read in case you ask for it again. An obvious questions here is: why doens't the Table code simply keep track of the position in the file at which each object starts, and fseek() to that location when needed? We have not implemented this, and the reason is as follows: the only situation that you can fseek() is when the archive being read is an actual file (i.e. not a piped command or the standard input). If the archive was an actual file on disk, you could have written it out with an attached scp file containing offsets into the file (using the "ark,scp:" prefix, see <a class="el" href="io.html#io_sec_specifiers_both">Writing an archive and a script file simultaneously</a>), and then provided that scp file to the program that needs to read the archive. This would be almost as time-efficient as reading the archive directly, since the code that reads in scp files is smart enough to avoid reopening files when not needed and calling fseek() unnecessarily. So treating file archives as a special case and caching offsets into the file would not solve any problems.</p>
<p>There are two separate problems that can happen when you read an archive in random access mode; these can both happen if you use just the "ark:" prefix with no additional options.</p><ul>
<li>If you ask for a key that is not present in the archive, the reading code is forced to read till the end of the archive to make sure it is not there.</li>
<li>Every time the code reads an object, it is forced to keep it in memory in case you ask for it later.</li>
</ul>
<p>With regard to the first problem (having to read till the end of the file), the way you can avoid this is to assert that the archive is sorted on key (using the normal string sorted order that "C" uses, and that the program "sort" uses if you do "export LC_ALL=C"). You can do this using the "s" option when reading archives: for example, the rspecifier "ark,s:-" instructs the code to read the standard input as an archive and expect it to be in sorted order. The Table code checks that what you have asserted is actually true, and will crash if not. Of course, you have to set up your scripts in such a way that the archives are actually sorted on key (usually this will be done in the initial feature-extraction stage).</p>
<p>With regard to the second problem (being forced to keep things in memory in case needed later), there are two solutions.</p>
<ul>
<li><p class="startli">The first solution, which is a rather brittle solution, is to provide the "once" option; for example, the rspecifier "ark,o:-" reads in from the standard input and asserts that you will only ask for each object once. To be able to assert this you would have to know something about how the program in question works and you would probably have to know that some other Table provided to the program does not contain any repeated keys (yes, Tables can have repeated keys as long as they are only accessed in sequential mode).</p>
<p class="startli">If you provide the "o" option the Table can deallocate objects after they have been accessed. However, this only works well if your archives are perfectly synchronized with no gaps or missing elements. For example, suppose you execute the command: </p><pre class="fragment"> some-program ark:somedir/some.ark "ark,o:some command|"
</pre><p> The program "some-program" will first iterate sequentially over the archive "somedir/some.ark" and then for each key it encounters, access the second archive via random access. Note that the order of command-line arguments is not arbitrary: we have tried to adopt the convention that rspecifiers that will be accessed sequentially appear before those that will be accessed via random access.</p>
<p class="startli">Suppose the two archives are mostly synchronized but may have gaps (i.e. missing keys, e.g. due to failures in feature extraction, data alignment, and so on). Any time there is a gap in the first archive, the program will have to cache the associated object from the second archive because it doesn't know that it won't be called for later (it can only throw away an object once you have read it). Gaps in the second archive are more serious, because if there is a gap of even one element, when the program asks for that key it will have to read right till the end of the second archive to look for it, and will have to cache all objects along the way.</p>
</li>
<li>The second solution, which is more robust, is to use the "called-sorted" (cs) option. This asserts that the objects will be requested in sorted order, and again this requires knowledge of how the program works, plus that any sequentially accessed archives are in sorted order. The "cs" option is normally most useful in conjunction with the "s" option. Suppose we execute the following command: <pre class="fragment"> some-program ark:somedir/some.ark "ark,s,cs:some command|"
</pre> We assume that both archives are in sorted order, and the the program does sequential access on the first archive and random access on the second. This is now robust to gaps in the archives. First imagine there is a gap in the first archive (e.g., its keys are 001, 002, 003, 081, 082, ...). When the second archive is searched for key 081 right after key 003, the code that reads the second archive will encounter keys 004, 005, and so on, but it can discard the associated objects because it knows that no key before 081 will be asked for again (thanks to the "cs" option). If there is a gap in the second archive, it can use the fact that the second archive is sorted to avoid searching till the end of the file (this is the job of the "s" option).</li>
</ul>
<h2><a class="anchor" id="io_sec_mapped"></a>
io_sec_mapped</h2>
<p>In order to condense a particular code pattern that was recurring in many programs, we have introduced the template type <a class="el" href="classkaldi_1_1RandomAccessTableReaderMapped.html" title="This class is for when you are reading something in random access, but it may actually be stored per-...">RandomAccessTableReaderMapped</a>. Unlike <a class="el" href="classkaldi_1_1RandomAccessTableReader.html" title="Allows random access to a collection of objects in an archive or script file; see The Table concept...">RandomAccessTableReader</a>, this takes two initializer arguments, for instance: </p><pre class="fragment">   std::string rspecifier, utt2spk_map_rspecifier; // get these from somewhere.
   RandomAccessTableReaderMapped&lt;BaseFloatMatrixHolder&gt; transform_reader(rspecifier,
                                                                         utt2spk_map_rspecifier);
</pre><p> If utt2spk_map_rspecifier is the empty string, this will behave just like a regular <a class="el" href="classkaldi_1_1RandomAccessTableReader.html" title="Allows random access to a collection of objects in an archive or script file; see The Table concept...">RandomAccessTableReader</a>. If it is nonempty, e.g. ark:data/train/utt2spk, it will read an utterance-to-speaker map from that location and whenever a particular string e.g. utt1 is queried, it will use that map to convert the utterance-id to a speaker-id (e.g. spk1) and use that as the key to query the table being read from rspecifier. The utterance-to-speaker map is also an archive because it happens that the Table code is the easiest way to read in such maps. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Kaldi</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
