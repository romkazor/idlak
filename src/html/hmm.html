<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Kaldi: HMM topology and transition modeling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 <td id="projectlogo"><a href="http://kaldi-asr.org/"><img alt="Logo" src="KaldiTextAndLogoSmall.png"/ style="padding: 3px 5px 1px 5px"></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname" style="display:none">Kaldi
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief" style="display:none"></div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hmm.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HMM topology and transition modeling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="hmm_intro"></a>
Introduction</h1>
<p>In this page we describe how HMM topologies are represented by Kaldi and how we model and train HMM transitions. We briefly mention how this interacts with decision trees; decision trees are covered more fully in <a class="el" href="tree_externals.html">How decision trees are used in Kaldi</a> and <a class="el" href="tree_internals.html">Decision tree internals</a>. For a list of classes and functions in this group, see <a class="el" href="group__hmm__group.html">Classes and functions related to HMM topology and transition modeling</a></p>
<h1><a class="anchor" id="hmm_topology"></a>
HMM topologies</h1>
<p>The class <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> is the way the user specifies to the toolkit the topology of the HMMs the phones. In the normal recipe, the scripts create in a file the text form of the <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object, which is then given to the command-line programs. To give some idea of what this object contains, below is the text format for the <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object in the "normal" case (the 3-state Bakis model): </p><pre class="fragment"> &lt;Topology&gt;
 &lt;TopologyEntry&gt;
 &lt;ForPhones&gt; 1 2 3 4 5 6 7 8 &lt;/ForPhones&gt;
 &lt;State&gt; 0 &lt;PdfClass&gt; 0
 &lt;Transition&gt; 0 0.5
 &lt;Transition&gt; 1 0.5
 &lt;/State&gt;
 &lt;State&gt; 1 &lt;PdfClass&gt; 1
 &lt;Transition&gt; 1 0.5
 &lt;Transition&gt; 2 0.5
 &lt;/State&gt;
 &lt;State&gt; 2 &lt;PdfClass&gt; 2
 &lt;Transition&gt; 2 0.5
 &lt;Transition&gt; 3 0.5
 &lt;/State&gt;
 &lt;State&gt; 3
 &lt;/State&gt;
 &lt;/TopologyEntry&gt;
 &lt;/Topology&gt;
</pre><p> There is one TopologyEntry in this particular <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object, and it covers phones 1 through 8 (so in this example there are just eight phones and they all share the same topology). There are three emitting states (i.e. states that have pdfs associated with them and 'emit' feature vectors); each has a self-loop and a transition to the next state. There is also a fourth, non-emitting state, state 3 (there is no &lt;PdfClass&gt; entry for it) which has no transitions out of it (implicitly, it connects to the next phone in the sequence). This is a standard feature of these topology entries; Kaldi treats the first state (state zero) as the start state, and the last state, which should always be nonemitting and have no transitions out of it, has final-probability one. You can treat the transition-probability to the last state as equivalent to the "final-probability" in a HMM. All of emitting the states in this particular example can have different pdf's in them (since the PdfClass numbers are all distinct). We can enforce tying by making the &lt;PdfClass&gt; numbers the same. The probabilities given in the <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object are those that are used to initialize training; the trained probabilities are specific to the context-dependent HMMs and are stored in the <a class="el" href="classkaldi_1_1TransitionModel.html">TransitionModel</a> object. The <a class="el" href="classkaldi_1_1TransitionModel.html">TransitionModel</a> stores the <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object as a class member, but be aware that the transition probabilities in the <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object are generally not used after initializing the <a class="el" href="classkaldi_1_1TransitionModel.html">TransitionModel</a> object. There is an exception to this, however; for nonemitting states that are non-final (i.e. those that have transitions out of them but no &lt;PdfClass&gt; entry), Kaldi does not train the transition probabilities and instead it uses the probabilities given in the <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object. The decision not to support trainable transition probabilities for non-emitting states simplifies our training mechanisms, and since it is not normal to have non-emitting states with transitions, we felt that this was no great loss.</p>
<h1><a class="anchor" id="pdf_class"></a>
Pdf-classes</h1>
<p>The pdf-class is a concept that relates to the <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object. The <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object specifies a prototype HMM for each phone. Each numbered state of a "prototype HMM" has two variables "forward_pdf_class" and "self_loop_pdf_class". The "self_loop_pdf_class" is a kind of pdf-class that is associated with self-loop transition. It is by default identical to "forward_pdf_class", but it can be used to define less-convectional HMM topologies where the pdfs on the self-loop and forward transitions are different. The decision to allow the pdf-class on just the self-loop to be different, while not embracing a fully "arc-based" representation where the pdfs on all transitions in the HMM are potentially independent, was made as a compromise, to allow for compatibility with previous versions of Kaldi while supporting the topology used in our "chain models" AKA lattice-free MMI. If two states have the same pdf_class variable, then they will always share the same probability distribution function (p.d.f.) if they are in the same phonetic context. This is because the decision-tree code does not get to "see" the HMM-state directly, it only gets to see the pdf-class. In the normal case the pdf-class is the same as the HMM state index (e.g. 0, 1 or 2), but pdf classes provide a way for the user to enforce sharing. This would mainly be useful if you wanted richer transition modeling but wanted to leave the acoustic model otherwise the same. Another function of the pdf-class is to specify nonemitting states. If the pdf-class for some HMM state is set to the constant <a class="el" href="group__hmm__group.html#gad94539d80f1ba0b8731c6692b624b7a3">kNoPdf</a> = -1, then the HMM state is nonemitting (it has no associated pdf). This can be achieved simply by omitting the &lt;PdfClass&gt; tag and associated number, in the text form of the object.</p>
<p>The set of pdf-classes for a particular prototype HMM is expected to start from zero and be contiguous (e.g. 0, 1, 2). This is for the convenience of the graph-building code, and does not lead to any loss of generality.</p>
<h1><a class="anchor" id="transition_model"></a>
Transition models (the TransitionModel object)</h1>
<p>The <a class="el" href="classkaldi_1_1TransitionModel.html">TransitionModel</a> object stores the transition probabilities and information about HMM topologies (it contains a <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object). The graph-building code depends on the <a class="el" href="classkaldi_1_1TransitionModel.html">TransitionModel</a> object to get the topology and transition probabilities (it also requires a <a class="el" href="classkaldi_1_1ContextDependencyInterface.html" title="context-dep-itf.h provides a link between the tree-building code in ../tree/, and the FST code in ...">ContextDependencyInterface</a> object to get the pdf-ids associated with particular phonetic contexts).</p>
<h2><a class="anchor" id="transition_model_how"></a>
How we model transition probabilities in Kaldi</h2>
<p>The decision that underlies a lot of the transition-modeling code is as follows: we have decided to make the transition probability of a context dependent HMM state depend on the following five things (you could view them as a 5-tuple):</p><ul>
<li>The phone (whose HMM we are in)</li>
<li>The source HMM-state (as interpreted by the <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object, i.e. normally 0, 1 or 2)</li>
<li>The <a class="el" href="tree_externals.html#pdf_id">forward-pdf-id</a> (i.e. the index of the forward transition pdfs associated with the state)</li>
<li>The <a class="el" href="tree_externals.html#pdf_id">self-loop-pdf-id</a> (i.e. the index of the self-loop pdfs associated with the state)</li>
<li>The index of the transition in the <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object.</li>
</ul>
<p>The last of these four items could be viewed as encoding the destination HMM-state in the <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object. The reason for making the transition probabilities depend on these things, is that this is the most fine-grained way we could model transitions without increasing the size of the compiled decoding graphs; it is also quite convenient for training the transition probabilities. In practice, with conventional setups it probably does not make any difference to model the transitions as precisely as this, and the HTK approach of sharing the transitions at the monophone level would probably be sufficient.</p>
<h2><a class="anchor" id="transition_model_mappings"></a>
The reason for transition-ids etc.</h2>
<p>The <a class="el" href="classkaldi_1_1TransitionModel.html">TransitionModel</a> object sets up a number of integer mappings when it is initialized, and is used by other parts of the code to perform these mappings. Apart from the quantities mentioned above, there are quantities called transition identifiers (transition-ids), transition indexes (which are not the same thing as transition-ids), and transition states. The reason we have introduced these identifiers and the associated mappings is so that we can use a completely FST-based training recipe. The most "natural" FST-based setups would have what we call pdf-ids on the input labels. However, bearing in mind that given our tree-building algorithms it will not always be possible to map uniquely from a pdf-id to a phone, this would make it hard to map from an input-label sequence to a phone sequence, and this is inconvenient for a number of reasons; it would also make it hard in general to train the transition probabilities using the information in the FST alone. For this reason we put identifiers called transition-ids on the input labels of the FST, and these can be mapped to the pdf-id but also to the phone and to a particular transition in a prototype HMM (as given in the <a class="el" href="classkaldi_1_1HmmTopology.html" title="A class for storing topology information for phones. ">HmmTopology</a> object).</p>
<h2><a class="anchor" id="transition_model_identifiers"></a>
Integer identifiers used by TransitionModel</h2>
<p>The following types of identifiers are used in the <a class="el" href="classkaldi_1_1TransitionModel.html">TransitionModel</a> interface. All of them are represented as type int32. Note that some of these quantities are one-based indices and some are zero-based. We have tried to avoid one-based indices as much as possible in the toolkit because they are not very compatible with C++ array indexing, but because OpenFst treats zero as a special case (meaning the special symbol epsilon), we have decided to allow one-based indexing for quantities that frequently appear as input symbols on FSTs. Most importantly, transition-ids are one based. Since we do not imagine <a class="el" href="tree_externals.html#pdf_id">pdf-ids</a> appearing very frequently as FST labels, and since we often use them as C++ array indexes, we have decided to make them zero-based but if they appear as FST input symbols (which should be rarely) we add one to them. When reading the <a class="el" href="classkaldi_1_1TransitionModel.html">TransitionModel</a> code, be aware that when indexing arrays with one-based quantities there are cases where we subtract one and some cases where we do not; this is documented where the member variables are declared. In any case, such code is not in the public interface so it should not lead to too much confusion. A complete list of the various integer quantities used in <a class="el" href="classkaldi_1_1TransitionModel.html">TransitionModel</a> are as follows:</p>
<ul>
<li>phone (one-based): this type of identifier is used throughout the toolkit; it can be converted to a phone name via an OpenFst symbol table. Not necessarily contiguous (the toolkit allows "skips" in the phone indices).</li>
<li>hmm-state (zero-based): this is an index into something of type <a class="el" href="classkaldi_1_1HmmTopology.html#aba67ff7bf4a95d8b1b33f1f41b385a74" title="TopologyEntry is a typedef that represents the topology of a single (prototype) state. ">HmmTopology::TopologyEntry</a>. In the normal case, it is one of {0, 1, 2}.</li>
<li>pdf, or pdf-id (zero-based): this is the index of the p.d.f., as originally allocated by the decision-tree clustering; (see <a class="el" href="tree_externals.html#pdf_id">PDF identifiers</a>). There would normally be several thousand pdf-ids in a system.</li>
<li>transition-state, or trans_state (one-based): this is an index that is defined by the <a class="el" href="classkaldi_1_1TransitionModel.html">TransitionModel</a> itself. Each possible triple of (phone, hmm-state, pdf) maps to a unique transition-state. Think of it is the finest granularity of HMM-state for which transitions are separately estimated.</li>
<li>transition-index, or trans_index (zero-based): this is an index into the "transitions" array of type <a class="el" href="structkaldi_1_1HmmTopology_1_1HmmState.html" title="A structure defined inside HmmTopology to represent a HMM state. ">HmmTopology::HmmState</a>. It numbers the transitions out of a particular transition-state.</li>
<li>transition-id, or trans_id (one-based): each of these corresponds to a unique transition probability in the transition model. There is a mapping from (transition-state, transition-index) to transition-id, and vice versa.</li>
</ul>
<p>There are also in the transition-modeling code reference to the following concepts:</p><ul>
<li>A tuple means a 4-tuple (phone, hmm-state, forward pdf, self-loop pdf) which is mappable to and from a transition-state.</li>
<li>A pair means a pair (transition-state, transition-index) which is mappable to and from a transition-id.</li>
</ul>
<h1><a class="anchor" id="hmm_transition_training"></a>
Training the transition model</h1>
<p>The training procedure for the transition model is very simple. The FSTs that we create (for both training and test) have transition-ids as their input labels. In training we do a Viterbi decoding that gives us the input-label sequence, which is a sequence of transition-ids (one for each feature vector). The statistics we accumulate for training transitions are essentially counts of how many times each transition-id was seen in training (the code itself uses floating-point occupation counts but these are just integers in our normal training setup). The function Transition::Update() does the ML update for each transition-state. This works in the "obvious" way. There are also some minor issues related to probability flooring and what to do if a particular transition-state is unseen; for these details, see the code.</p>
<h1><a class="anchor" id="hmm_alignment"></a>
Alignments in Kaldi</h1>
<p>At this point we introduce the concept of an alignment. By "alignment", we generally mean something of type vector&lt;int32&gt;, which contains a sequence of transition-ids (c.f. <a class="el" href="hmm.html#transition_model_identifiers">Integer identifiers used by TransitionModel</a>) whose length is the same as the utterance the alignment corresponds to. This sequence of transition-ids would generally be obtained from the decoder as the input-label sequence. Alignments are used in training time for Viterbi training, and in test time for adaptation. Because transition-ids encode the phone information, it is possible to work out the phonetic sequence from an alignment (c.f. <a class="el" href="group__hmm__group.html#ga8de8a15a25238f4a7834e4b38ccf3a4b" title="SplitToPhones splits up the TransitionIds in &quot;alignment&quot; into their individual phones (one vector per...">SplitToPhones()</a> and <a class="el" href="ali-to-phones_8cc.html">ali-to-phones.cc</a>).</p>
<p>We often need to deal with collections of alignments indexed by utterance. To do this conveniently, we read and write alignments with tables; see <a class="el" href="table_examples.html#table_examples_ali">I/O with alignments</a> for more information.</p>
<p>The function <a class="el" href="group__hmm__group.html#gac4646cf7b9adc8531feb51d99b9a80c9">ConvertAlignment()</a> (c.f. the command-line program <a class="el" href="convert-ali_8cc.html">convert-ali</a>) converts alignments from one transition-model to another. The typical case is where you have alignments created using one transition-model (created from a particular decision tree) and want to convert them to be valid for another transition model with a different tree. It optionally takes a mapping from the original phones to a new phone set; this feature is not normally needed but we have used it when dealing with simplified models based on a reduced (clustered) phone set.</p>
<p>Programs that read in alignments generally have the suffix "-ali".</p>
<h1><a class="anchor" id="hmm_post"></a>
State-level posteriors</h1>
<p>State-level posteriors are an extension of the "alignment" concept (previous section), except that instead of having a single transition-id per frame we have an arbitrary number of transition-ids per frame, and each one has a weight. It is stored in the following type of structure: </p><pre class="fragment">typedef std::vector&lt;std::vector&lt;std::pair&lt;int32, BaseFloat&gt; &gt; &gt; Posterior;
</pre><p> where if we have an object "post" of type Posterior, post.size() will be equal to the length of the utterance in frames, and post[i] is a list of pairs (stored as a vector), where each pair consists of a (transition-id, posterior).</p>
<p>In the current programs, there are only two ways to create posteriors: either</p><ul>
<li>By converting alignments to posteriors using the program ali-to-post, which gives us a rather trivial Posterior object where each frame has a single transition-id with unit posterior</li>
<li>By modifying posteriors using the program weight-silence-post, which is usually used to weight down the posteriors corresponding to silence phones.</li>
</ul>
<p>In future, when lattice generation is added, we will add utilities to create posteriors from lattices.</p>
<p>Programs that read in posteriors don't have a suffix comparable to "-ali", which is the suffix for programs that read in alignments. This is for brevity; reading in state-level posteriors is considered the "default" behavior of programs that need this type of alignment information.</p>
<h1><a class="anchor" id="hmm_gpost"></a>
Gaussian-level posteriors</h1>
<p>A set of Gaussian-level posteriors for an utterance may be stored using the following typedef: </p><pre class="fragment">typedef std::vector&lt;std::vector&lt;std::pair&lt;int32, Vector&lt;BaseFloat&gt; &gt; &gt; &gt; GauPost;
</pre><p> This is like the Posterior structure, except the floating-point value (which represents the posterior of the state) is now a vector of floating-point values, one for each Gaussian in the state. The size of the vector would be the same as the number of Gaussians in the pdf corresponding to the transition-id which is the first element of the pair.</p>
<p>The program post-to-gpost converts Posterior structures into GauPost structures; it uses the model and the features to compute the Gaussian-level posteriors. This is mainly useful in situations where we may need to compute Gaussian-level posteriors with a different model or features than the ones we need to accumulate statistics with. Programs that read in Gaussian-level posteriors have the suffix "-gpost".</p>
<h1><a class="anchor" id="hmm_graph"></a>
Functions for converting HMMs to FSTs</h1>
<p>A complete list of functions and classes involved in converting HMMs to FSTs may be found <a class="el" href="group__hmm__group__graph.html">here</a>.</p>
<h2><a class="anchor" id="hmm_graph_get_h_transducer"></a>
GetHTransducer()</h2>
<p>The most important one is the function GetHTranducer(), declared as follows: </p><div class="fragment"><div class="line">fst::VectorFst&lt;fst::StdArc&gt;*</div><div class="line"><a class="code" href="group__hmm__group__graph.html#gade0dda4e298562cc32dee6962e0ff0c9">GetHTransducer</a> (<span class="keyword">const</span> std::vector&lt;std::vector&lt;int32&gt; &gt; &amp;ilabel_info,</div><div class="line">                <span class="keyword">const</span> ContextDependencyInterface &amp;ctx_dep,</div><div class="line">                <span class="keyword">const</span> TransitionModel &amp;trans_model,</div><div class="line">                <span class="keyword">const</span> HTransducerConfig &amp;config,</div><div class="line">                std::vector&lt;int32&gt; *disambig_syms_left);</div></div><!-- fragment --><p> There are aspects of this function which will be hard to understand without having first understood the <a class="el" href="tree_externals.html#tree_ilabel">ilabel_info</a> object, the <a class="el" href="tree_externals.html#tree_ctxdep">ContextDependencyInterface</a> interface, and at least the basics of how FSTs are used in speech recognition. This function returns an FST whose input labels are <a class="el" href="hmm.html#transition_model_identifiers">transition-ids</a> and whose output labels represent context-dependent phones (they are indices into the <a class="el" href="tree_externals.html#tree_ilabel">ilabel_info</a> object). The FST it returns has a state that is both initial and final, and all the transitions out of it have output-labels (for efficient composition with CLG). Each transition out of it will typically enter a structure representing a 3-state HMM, and then loop back to the initial state. The FST returned <a class="el" href="group__hmm__group__graph.html#gade0dda4e298562cc32dee6962e0ff0c9" title="Returns the H tranducer; result owned by caller. ">GetHTransducer()</a> will only be valid for the phonetic contexts represented in ilabel_info, which the caller can specify. This is useful because for wide-context systems there can be a large number of contexts, most of which are never used. The ilabel_info object can be obtained from the ContextFst object (which represents C) after composing it with something, and it contains just the contexts that have been used. We would then provide this same ilabel_info object to <a class="el" href="group__hmm__group__graph.html#gade0dda4e298562cc32dee6962e0ff0c9" title="Returns the H tranducer; result owned by caller. ">GetHTransducer()</a> to get an H transducer that covers everything we need.</p>
<p>Note that <a class="el" href="group__hmm__group__graph.html#gade0dda4e298562cc32dee6962e0ff0c9" title="Returns the H tranducer; result owned by caller. ">GetHTransducer()</a> function does not include the self-loops. These must be added later by the function <a class="el" href="group__hmm__group__graph.html#ga859d84c809f51c078075500cdca5a0df" title="For context, see AddSelfLoops(). ">AddSelfLoops()</a>; it is normally convenient to only add the self-loops after all stages of decoding-graph optimization.</p>
<h2><a class="anchor" id="hmm_graph_config"></a>
The HTransducerConfig configuration class</h2>
<p>The <a class="el" href="structkaldi_1_1HTransducerConfig.html" title="Configuration class for the GetHTransducer() function; see The HTransducerConfig configuration class ...">HTransducerConfig</a> configuration class controls the behavior of GetHTransducer.</p>
<ul>
<li>The variable trans_prob_scale is the transition probability scale. When transition probabilities are included in the graph, they are included with this scale. As a command-line option this is called &ndash;transition-scale. See <a class="el" href="hmm.html#hmm_scale">Scaling of transition and acoustic probabilities</a> for a discussion of the appropriate scale to use.</li>
</ul>
<h2><a class="anchor" id="hmm_graph_get_hmm_as_fst"></a>
The function GetHmmAsFst()</h2>
<p>The function GetHmmAsFst() takes a phonetic context window and returns the corresponding finite state acceptor with transition-ids as the symbols. This is used in <a class="el" href="group__hmm__group__graph.html#gade0dda4e298562cc32dee6962e0ff0c9" title="Returns the H tranducer; result owned by caller. ">GetHTransducer()</a>. A function GetHmmAsFstSimple() that takes fewer options is also provided as a form of documentation, in order to show in principle how the process works.</p>
<h2><a class="anchor" id="hmm_graph_add_self_loops"></a>
AddSelfLoops()</h2>
<p>The <a class="el" href="group__hmm__group__graph.html#ga859d84c809f51c078075500cdca5a0df" title="For context, see AddSelfLoops(). ">AddSelfLoops()</a> function adds self-loops to a graph that has been created without self-loops. A typical setup is to create the H transducer without self-loops, compose with CLG, do determinization and minimization, and then add the self-loops. This enables more efficient determinization and minimization. The <a class="el" href="group__hmm__group__graph.html#ga859d84c809f51c078075500cdca5a0df" title="For context, see AddSelfLoops(). ">AddSelfLoops()</a> function has the option to reorder the transitions; see below <a class="el" href="hmm.html#hmm_reorder">Reordering transitions</a> for more details on this. It also takes a transition-probability scale, "self_loop_scale", which does not have to be the same as the normal transition-probability scale; for more on this, see below <a class="el" href="hmm.html#hmm_scale">Scaling of transition and acoustic probabilities</a>.</p>
<h2><a class="anchor" id="hmm_graph_add_transition_probs"></a>
Adding transition probabilities to FSTs</h2>
<p>The <a class="el" href="group__hmm__group__graph.html#ga67218f63ca04115462e0af7143e12ddb" title="Adds transition-probs, with the supplied scales (see Scaling of transition and acoustic probabilities...">AddTransitionProbs()</a> function adds transition probabilities to an FST. The reason this is useful is so that graphs can be created without transition probabilities on them (i.e. without the component of the weights that arises from the HMM transitions), and these can be added in later; this makes it possible to use the same graph on different iterations of training the model, and keep the transition-probabilities in the graph up to date. Creating the graph without transition-probabilities is accomplished by using a zero value for trans_prob_scale (command-line option: &ndash;transition-scale). In training time, our scripts tend to store the graphs on disk without the transition probabilities, and then each time we realign we add in the currently valid transition probabilities.</p>
<h1><a class="anchor" id="hmm_reorder"></a>
Reordering transitions</h1>
<p>The <a class="el" href="group__hmm__group__graph.html#ga859d84c809f51c078075500cdca5a0df" title="For context, see AddSelfLoops(). ">AddSelfLoops()</a> function takes a boolean option "reorder" which tells it to reorder transion-probabilities so the self-loop comes after the transition out of the state. Where applicable this becomes a boolean command-line option, e.g. you can do &ndash;reorder=true to enable reordering during graph creation. This option makes the "simple" and "faster" decoders more efficient (see <a class="el" href="decoders.html">Decoders used in the Kaldi toolkit</a>), although it is not compatible with the "kaldi" decoder.</p>
<p>The idea of reordering is that we switch the order of the self-loop arcs with all the other arcs that come out of a state, so the self-loop is located at the destination state of each of the other arcs. For this to work, we have to ensure that the FST has certain properties, namely that all the arcs into a particular state must induce the same self-loop (also, a state with a self-loop cannot have input arcs with epsilon inputs, or be the start state). The <a class="el" href="group__hmm__group__graph.html#ga859d84c809f51c078075500cdca5a0df" title="For context, see AddSelfLoops(). ">AddSelfLoops()</a> function modifies the graphs to ensure that they have this property. A similar property is required even if the "reorder" option is set to false. The graphs created with the "reorder" option are exactly equivalent to the non-reordered graphs in terms of the acoustic and transition-model probabilities you get when decoding an utterance. The transition-ids on the resulting alignment are in a different order, but this does not matter given the ways that we make use of these alignments.</p>
<h1><a class="anchor" id="hmm_scale"></a>
Scaling of transition and acoustic probabilities</h1>
<p>There are three types of scaling that can be applied in Kaldi: </p><table border="1">
<tr>
<td>Name in code </td><td>Name in command-line arguments </td><td>Example value (train)  </td><td>Example value (test)   </td></tr>
<tr>
<td>acoustic_scale  </td><td>&ndash;acoustic-scale=?  </td><td>0.1  </td><td>0.08333   </td></tr>
<tr>
<td>self_loop_scale  </td><td>&ndash;self-loop-scale=?  </td><td>0.1  </td><td>0.1   </td></tr>
<tr>
<td>transition_scale  </td><td>&ndash;transition-scale=?  </td><td>1.0  </td><td>1.0   </td></tr>
</table>
<p>You may notice that there is no language model scale on this list; everything is scaled relative to the language model. Also we don't support a word insertion penalty, in general (although the "kaldi" decoder does support this). The idea is that the language model represents "real" probabilities so it makes sense to scale everything else relative to them. The scales during training time are the scales we use in decoding to get Viterbi alignments. In general, we use a figure of 0.1 whenever a parameter is not to critical and is expected to be small. The acoustic scale used during test is quite critical and is typically tuned to the task. We now explain what these three scales do:</p>
<ul>
<li>The acoustic scale is the scale applied to the acoustics (i.e. to the log-likelihood of a frame given an acoustic state).</li>
<li>The transition scale is the scale on the transition probabilities, but this only applies to HMM states that have multiple transitions out of them; it applies to the relative weight between such transitions. It does not have any effect for typical topologoes.</li>
<li>The self-loop scale is the scale that we apply to the self-loops. More specifically, when we add the self-loop, let the probability mass given to the self-loop be p and the mass given to the rest be (1-p). We add a self-loop with log-probability self_loop_scale * log(p), and add (self_loop_scale * log(1-p)) to all the other log transition probabilities out of that state. (Note: in the initial stage of graph creation we create a graph without self-loops, and with the non-self-loop transition probabilities renormalized to sum to one). In typical topologies, the self-loop scale is the only scale that matters.</li>
</ul>
<p>The reason we feel it might make sense to apply a different probability scale to the self-loops versus the normal transition scale is we think they could be dictating the probabilities of events at different timescales. A slightly more subtle argument is the following. All the transition probabilities can be regarded as "real" probabilities (comparable to LM probabilities), because the problem of correlation between acoustic probabilities does not occur for transitions. However, a problem arises because we use the Viterbi algorithm in testing (and in our case, in training too). The transition probabilities would only represent real probabilities when summed over, as in the forward-backward algorithm. We expect this to be more of an issue for the self-loops than for probabilities that dictate the weight to give entirely different paths through the HMM, as in the latter case the acoustic distributions will often be quite disjoint, and the difference between forward-backward and Viterbi will be small. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Kaldi</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
