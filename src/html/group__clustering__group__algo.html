<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Kaldi: Algorithms for clustering</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 <td id="projectlogo"><a href="http://kaldi-asr.org/"><img alt="Logo" src="KaldiTextAndLogoSmall.png"/ style="padding: 3px 5px 1px 5px"></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname" style="display:none">Kaldi
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief" style="display:none"></div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__clustering__group__algo.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms for clustering<div class="ingroups"><a class="el" href="group__clustering__group.html">Classes and functions related to clustering</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>See <a class="el" href="clustering.html">Clustering mechanisms in Kaldi</a> for context.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Algorithms for clustering:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__clustering__group__algo.png" border="0" alt="" usemap="#group____clustering____group____algo"/>
<map name="group____clustering____group____algo" id="group____clustering____group____algo">
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkaldi_1_1RefineClustersOptions.html">RefineClustersOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkaldi_1_1ClusterKMeansOptions.html">ClusterKMeansOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkaldi_1_1TreeClusterOptions.html">TreeClusterOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae13c55f284aeed0245a059489a0f1960"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clustering__group__algo.html#gae13c55f284aeed0245a059489a0f1960">ClusterBottomUp</a> (const std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &amp;points, <a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> thresh, int32 min_clust, std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; *clusters_out, std::vector&lt; int32 &gt; *assignments_out)</td></tr>
<tr class="memdesc:gae13c55f284aeed0245a059489a0f1960"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bottom-up clustering algorithm.  <a href="group__clustering__group__algo.html#gae13c55f284aeed0245a059489a0f1960">More...</a><br /></td></tr>
<tr class="separator:gae13c55f284aeed0245a059489a0f1960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf085c40585c9f63eb7d21da94a13cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clustering__group__algo.html#gacf085c40585c9f63eb7d21da94a13cbe">ClusterBottomUpCompartmentalized</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &gt; &amp;points, <a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> thresh, int32 min_clust, std::vector&lt; std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &gt; *clusters_out, std::vector&lt; std::vector&lt; int32 &gt; &gt; *assignments_out)</td></tr>
<tr class="memdesc:gacf085c40585c9f63eb7d21da94a13cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a bottom-up clustering where the points are pre-clustered in a set of compartments, such that only points in the same compartment are clustered together.  <a href="group__clustering__group__algo.html#gacf085c40585c9f63eb7d21da94a13cbe">More...</a><br /></td></tr>
<tr class="separator:gacf085c40585c9f63eb7d21da94a13cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc769f73ac32a09d383bfbd139f6326b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clustering__group__algo.html#gabc769f73ac32a09d383bfbd139f6326b">RefineClusters</a> (const std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &amp;points, std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; *clusters, std::vector&lt; int32 &gt; *assignments, <a class="el" href="structkaldi_1_1RefineClustersOptions.html">RefineClustersOptions</a> cfg=<a class="el" href="structkaldi_1_1RefineClustersOptions.html">RefineClustersOptions</a>())</td></tr>
<tr class="memdesc:gabc769f73ac32a09d383bfbd139f6326b"><td class="mdescLeft">&#160;</td><td class="mdescRight">RefineClusters is mainly used internally by other clustering algorithms.  <a href="group__clustering__group__algo.html#gabc769f73ac32a09d383bfbd139f6326b">More...</a><br /></td></tr>
<tr class="separator:gabc769f73ac32a09d383bfbd139f6326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69018185a19b01f73228875aa07e3135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clustering__group__algo.html#ga69018185a19b01f73228875aa07e3135">ClusterKMeans</a> (const std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &amp;points, int32 num_clust, std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; *clusters_out, std::vector&lt; int32 &gt; *assignments_out, <a class="el" href="structkaldi_1_1ClusterKMeansOptions.html">ClusterKMeansOptions</a> cfg=<a class="el" href="structkaldi_1_1ClusterKMeansOptions.html">ClusterKMeansOptions</a>())</td></tr>
<tr class="memdesc:ga69018185a19b01f73228875aa07e3135"><td class="mdescLeft">&#160;</td><td class="mdescRight">ClusterKMeans is a K-means-like clustering algorithm.  <a href="group__clustering__group__algo.html#ga69018185a19b01f73228875aa07e3135">More...</a><br /></td></tr>
<tr class="separator:ga69018185a19b01f73228875aa07e3135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2937c106b02a420e044390b465014fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clustering__group__algo.html#gad2937c106b02a420e044390b465014fa">TreeCluster</a> (const std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &amp;points, int32 max_clust, std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; *clusters_out, std::vector&lt; int32 &gt; *assignments_out, std::vector&lt; int32 &gt; *clust_assignments_out, int32 *num_leaves_out, <a class="el" href="structkaldi_1_1TreeClusterOptions.html">TreeClusterOptions</a> cfg=<a class="el" href="structkaldi_1_1TreeClusterOptions.html">TreeClusterOptions</a>())</td></tr>
<tr class="memdesc:gad2937c106b02a420e044390b465014fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">TreeCluster is a top-down clustering algorithm, using a binary tree (not necessarily balanced).  <a href="group__clustering__group__algo.html#gad2937c106b02a420e044390b465014fa">More...</a><br /></td></tr>
<tr class="separator:gad2937c106b02a420e044390b465014fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6c80e7da6b44a697295be2de67ea1e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__clustering__group__algo.html#gae6c80e7da6b44a697295be2de67ea1e7">ClusterTopDown</a> (const std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &amp;points, int32 max_clust, std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; *clusters_out, std::vector&lt; int32 &gt; *assignments_out, <a class="el" href="structkaldi_1_1TreeClusterOptions.html">TreeClusterOptions</a> cfg=<a class="el" href="structkaldi_1_1TreeClusterOptions.html">TreeClusterOptions</a>())</td></tr>
<tr class="memdesc:gae6c80e7da6b44a697295be2de67ea1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clustering algorithm that internally uses TreeCluster, but does not give you the information about the structure of the tree.  <a href="group__clustering__group__algo.html#gae6c80e7da6b44a697295be2de67ea1e7">More...</a><br /></td></tr>
<tr class="separator:gae6c80e7da6b44a697295be2de67ea1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>See <a class="el" href="clustering.html">Clustering mechanisms in Kaldi</a> for context. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae13c55f284aeed0245a059489a0f1960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae13c55f284aeed0245a059489a0f1960">&#9670;&nbsp;</a></span>ClusterBottomUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> ClusterBottomUp </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a>&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>min_clust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>clusters_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32 &gt; *&#160;</td>
          <td class="paramname"><em>assignments_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A bottom-up clustering algorithm. </p>
<p>There are two parameters that control how many clusters we get: a "max_merge_thresh" which is a threshold for merging clusters, and a min_clust which puts a floor on the number of clusters we want. Set max_merge_thresh = large to use the min_clust only, or min_clust to 0 to use the max_merge_thresh only.</p>
<p>The algorithm is: </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (num-clusters &gt; min_clust &amp;&amp; smallest_merge_cost &lt;= max_merge_thresh)</div><div class="line">    merge the closest two clusters.</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[in] Points to be clustered (may not contain NULL pointers) </td></tr>
    <tr><td class="paramname">thresh</td><td>[in] Threshold on cost change from merging clusters; clusters won't be merged if the cost is more than this </td></tr>
    <tr><td class="paramname">min_clust</td><td>[in] Minimum number of clusters desired; we'll stop merging after reaching this number. </td></tr>
    <tr><td class="paramname">clusters_out</td><td>[out] If non-NULL, will be set to a vector of size equal to the number of output clusters, containing the clustered statistics. Must be empty when called. </td></tr>
    <tr><td class="paramname">assignments_out</td><td>[out] If non-NULL, will be resized to the number of points, and each element is the index of the cluster that point was assigned to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the total objf change relative to all clusters being separate, which is a negative. Note that this is not the same as what the other clustering algorithms return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cluster-utils_8cc_source.html#l00407">407</a> of file <a class="el" href="cluster-utils_8cc_source.html">cluster-utils.cc</a>.</p>

<p class="reference">References <a class="el" href="cluster-utils_8cc_source.html#l00249">BottomUpClusterer::Cluster()</a>, <a class="el" href="stl-utils_8h_source.html#l00199">kaldi::ContainsNullPointers()</a>, <a class="el" href="kaldi-error_8h_source.html#l00168">KALDI_ASSERT</a>, and <a class="el" href="kaldi-error_8h_source.html#l00135">KALDI_VLOG</a>.</p>

<p class="reference">Referenced by <a class="el" href="build-tree-utils_8cc_source.html#l00599">kaldi::ClusterEventMapGetMapping()</a>, <a class="el" href="am-diag-gmm_8cc_source.html#l00195">kaldi::ClusterGaussiansToUbm()</a>, and <a class="el" href="cluster-utils-test_8cc_source.html#l00231">kaldi::TestClusterBottomUp()</a>.</p>
<div class="fragment"><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                                                             {</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;  <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(max_merge_thresh &gt;= 0.0 &amp;&amp; min_clust &gt;= 0);</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;  <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(!<a class="code" href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">ContainsNullPointers</a>(points));</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;  int32 npoints = points.size();</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  <span class="comment">// make sure fits in uint_smaller and does not hit the -1 which is reserved.</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(<span class="keyword">sizeof</span>(<a class="code" href="namespacekaldi.html#ab92ebd71b8f6dfc5a79eea425cb41a97">uint_smaller</a>)==<span class="keyword">sizeof</span>(uint32) ||</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;               npoints &lt; static_cast&lt;int32&gt;(static_cast&lt;uint_smaller&gt;(-1)));</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  <a class="code" href="group__error__group.html#ga16c81ec6ff3ba04c6ff96fdaed9d854e">KALDI_VLOG</a>(2) &lt;&lt; <span class="stringliteral">&quot;Initializing clustering object.&quot;</span>;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;  BottomUpClusterer bc(points, max_merge_thresh, min_clust, clusters_out, assignments_out);</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;  <a class="code" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> ans = bc.Cluster();</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;  <span class="keywordflow">if</span> (clusters_out) <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(!<a class="code" href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">ContainsNullPointers</a>(*clusters_out));</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;  <span class="keywordflow">return</span> ans;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;}</div><div class="ttc" id="namespacekaldi_html_a8b1bd2bab67151dfdf3acbe70b8341f1"><div class="ttname"><a href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">kaldi::ContainsNullPointers</a></div><div class="ttdeci">bool ContainsNullPointers(const std::vector&lt; A *&gt; &amp;v)</div><div class="ttdoc">Returns true if the vector of pointers contains NULL pointers. </div><div class="ttdef"><b>Definition:</b> <a href="stl-utils_8h_source.html#l00199">stl-utils.h:199</a></div></div>
<div class="ttc" id="namespacekaldi_html_aa66ff8367094543664b3b6a13d77c139"><div class="ttname"><a href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">kaldi::BaseFloat</a></div><div class="ttdeci">float BaseFloat</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-types_8h_source.html#l00029">kaldi-types.h:29</a></div></div>
<div class="ttc" id="group__error__group_html_gad5710173d69cddcda4fa21ded3c77f16"><div class="ttname"><a href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a></div><div class="ttdeci">#define KALDI_ASSERT(cond)</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-error_8h_source.html#l00168">kaldi-error.h:168</a></div></div>
<div class="ttc" id="group__error__group_html_ga16c81ec6ff3ba04c6ff96fdaed9d854e"><div class="ttname"><a href="group__error__group.html#ga16c81ec6ff3ba04c6ff96fdaed9d854e">KALDI_VLOG</a></div><div class="ttdeci">#define KALDI_VLOG(v)</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-error_8h_source.html#l00135">kaldi-error.h:135</a></div></div>
<div class="ttc" id="namespacekaldi_html_ab92ebd71b8f6dfc5a79eea425cb41a97"><div class="ttname"><a href="namespacekaldi.html#ab92ebd71b8f6dfc5a79eea425cb41a97">kaldi::uint_smaller</a></div><div class="ttdeci">uint16 uint_smaller</div><div class="ttdef"><b>Definition:</b> <a href="cluster-utils_8cc_source.html#l00032">cluster-utils.cc:32</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gacf085c40585c9f63eb7d21da94a13cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf085c40585c9f63eb7d21da94a13cbe">&#9670;&nbsp;</a></span>ClusterBottomUpCompartmentalized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> ClusterBottomUpCompartmentalized </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a>&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>min_clust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &gt; *&#160;</td>
          <td class="paramname"><em>clusters_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int32 &gt; &gt; *&#160;</td>
          <td class="paramname"><em>assignments_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a bottom-up clustering where the points are pre-clustered in a set of compartments, such that only points in the same compartment are clustered together. </p>
<p>The compartment and pair of points with the smallest merge cost is selected and the points are clustered. The result stays in the same compartment. The code does not merge compartments, and hence assumes that the number of compartments is smaller than the 'min_clust' option. The clusters in "clusters_out" are newly allocated and owned by the caller. </p>

<p class="definition">Definition at line <a class="el" href="cluster-utils_8cc_source.html#l00653">653</a> of file <a class="el" href="cluster-utils_8cc_source.html">cluster-utils.cc</a>.</p>

<p class="reference">References <a class="el" href="cluster-utils_8cc_source.html#l00495">CompartmentalizedBottomUpClusterer::Cluster()</a>, <a class="el" href="stl-utils_8h_source.html#l00199">kaldi::ContainsNullPointers()</a>, and <a class="el" href="kaldi-error_8h_source.html#l00168">KALDI_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="build-tree-utils_8cc_source.html#l00863">kaldi::ClusterEventMapToNClustersRestrictedByMap()</a>, and <a class="el" href="am-diag-gmm_8cc_source.html#l00195">kaldi::ClusterGaussiansToUbm()</a>.</p>
<div class="fragment"><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                                                    {</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;  <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(thresh &gt;= 0.0 &amp;&amp; min_clust &gt;= 0);</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;  int32 npoints = 0, num_non_empty_compartments = 0;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;  <span class="keywordflow">for</span> (vector&lt; vector&lt;Clusterable*&gt; &gt;::const_iterator itr = points.begin(),</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;           end = points.end(); itr != end; ++itr) {</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(!<a class="code" href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">ContainsNullPointers</a>(*itr));</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;    npoints += itr-&gt;size();</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    <span class="keywordflow">if</span> (itr-&gt;size() &gt; 0) num_non_empty_compartments++;</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;  }</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;  <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(min_clust &gt;= num_non_empty_compartments);  <span class="comment">// Code does not merge compartments.</span></div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;  <span class="comment">// make sure fits in uint_smaller and does not hit the -1 which is reserved.</span></div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(<span class="keyword">sizeof</span>(<a class="code" href="namespacekaldi.html#ab92ebd71b8f6dfc5a79eea425cb41a97">uint_smaller</a>)==<span class="keyword">sizeof</span>(uint32) ||</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;               npoints &lt; static_cast&lt;int32&gt;(static_cast&lt;uint_smaller&gt;(-1)));</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;  CompartmentalizedBottomUpClusterer bc(points, thresh, min_clust);</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;  <a class="code" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> ans = bc.Cluster(clusters_out, assignments_out);</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;  <span class="keywordflow">if</span> (clusters_out) {</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;    <span class="keywordflow">for</span> (vector&lt; vector&lt;Clusterable*&gt; &gt;::iterator itr = clusters_out-&gt;begin(),</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;             end = clusters_out-&gt;end(); itr != end; ++itr) {</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;      <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(!<a class="code" href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">ContainsNullPointers</a>(*itr));</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;    }</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  }</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;  <span class="keywordflow">return</span> ans;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;}</div><div class="ttc" id="namespacekaldi_html_a8b1bd2bab67151dfdf3acbe70b8341f1"><div class="ttname"><a href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">kaldi::ContainsNullPointers</a></div><div class="ttdeci">bool ContainsNullPointers(const std::vector&lt; A *&gt; &amp;v)</div><div class="ttdoc">Returns true if the vector of pointers contains NULL pointers. </div><div class="ttdef"><b>Definition:</b> <a href="stl-utils_8h_source.html#l00199">stl-utils.h:199</a></div></div>
<div class="ttc" id="namespacekaldi_html_aa66ff8367094543664b3b6a13d77c139"><div class="ttname"><a href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">kaldi::BaseFloat</a></div><div class="ttdeci">float BaseFloat</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-types_8h_source.html#l00029">kaldi-types.h:29</a></div></div>
<div class="ttc" id="group__error__group_html_gad5710173d69cddcda4fa21ded3c77f16"><div class="ttname"><a href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a></div><div class="ttdeci">#define KALDI_ASSERT(cond)</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-error_8h_source.html#l00168">kaldi-error.h:168</a></div></div>
<div class="ttc" id="namespacekaldi_html_ab92ebd71b8f6dfc5a79eea425cb41a97"><div class="ttname"><a href="namespacekaldi.html#ab92ebd71b8f6dfc5a79eea425cb41a97">kaldi::uint_smaller</a></div><div class="ttdeci">uint16 uint_smaller</div><div class="ttdef"><b>Definition:</b> <a href="cluster-utils_8cc_source.html#l00032">cluster-utils.cc:32</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga69018185a19b01f73228875aa07e3135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69018185a19b01f73228875aa07e3135">&#9670;&nbsp;</a></span>ClusterKMeans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> ClusterKMeans </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>num_clust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>clusters_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32 &gt; *&#160;</td>
          <td class="paramname"><em>assignments_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkaldi_1_1ClusterKMeansOptions.html">ClusterKMeansOptions</a>&#160;</td>
          <td class="paramname"><em>cfg</em> = <code><a class="el" href="structkaldi_1_1ClusterKMeansOptions.html">ClusterKMeansOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ClusterKMeans is a K-means-like clustering algorithm. </p>
<p>It starts with pseudo-random initialization of points to clusters and uses RefineClusters to iteratively improve the cluster assignments. It does this for multiple iterations and picks the result with the best objective function.</p>
<p>ClusterKMeans implicitly uses <a class="el" href="namespacekaldi.html#a70777edd81d4056098f79b9cd3bffb8b">Rand()</a>. It will not necessarily return the same value on different calls. Use sRand() if you want consistent results. The algorithm used in ClusterKMeans is a "k-means-like" algorithm that tries to be as efficient as possible. Firstly, since the algorithm it uses includes random initialization, it tries the whole thing cfg.num_tries times and picks the one with the best objective function. Each try, it does as follows: it randomly initializes points to clusters, and then for cfg.num_iters iterations it calls <a class="el" href="group__clustering__group__algo.html#gabc769f73ac32a09d383bfbd139f6326b" title="RefineClusters is mainly used internally by other clustering algorithms. ">RefineClusters()</a>. The options to <a class="el" href="group__clustering__group__algo.html#gabc769f73ac32a09d383bfbd139f6326b" title="RefineClusters is mainly used internally by other clustering algorithms. ">RefineClusters()</a> are given by cfg.refine_cfg. Calling RefineClusters once will always be at least as good as doing one iteration of reassigning points to clusters, but will generally be quite a bit better (without taking too much extra time).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[in] points to be clustered (must be all non-NULL). </td></tr>
    <tr><td class="paramname">num_clust</td><td>[in] number of clusters requested (it will always return exactly this many, or will fail if num_clust &gt; points.size()). </td></tr>
    <tr><td class="paramname">clusters_out</td><td>[out] may be NULL; if non-NULL, should be empty when called. Will be set to a vector of statistics corresponding to the output clusters. </td></tr>
    <tr><td class="paramname">assignments_out</td><td>[out] may be NULL; if non-NULL, will be set to a vector of same size as "points", which says for each point which cluster it is assigned to. </td></tr>
    <tr><td class="paramname">cfg</td><td>[in] configuration class specifying options to the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the objective function improvement versus everything being in the same cluster. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cluster-utils_8cc_source.html#l00986">986</a> of file <a class="el" href="cluster-utils_8cc_source.html">cluster-utils.cc</a>.</p>

<p class="reference">References <a class="el" href="cluster-utils_8cc_source.html#l00918">kaldi::ClusterKMeansOnce()</a>, <a class="el" href="stl-utils_8h_source.html#l00199">kaldi::ContainsNullPointers()</a>, <a class="el" href="stl-utils_8h_source.html#l00186">kaldi::DeletePointers()</a>, <a class="el" href="mikolov-rnnlm-lib_8cc_source.html#l00066">rnnlm::i</a>, <a class="el" href="kaldi-error_8h_source.html#l00168">KALDI_ASSERT</a>, <a class="el" href="cluster-utils_8h_source.html#l00163">ClusterKMeansOptions::num_iters</a>, and <a class="el" href="cluster-utils_8h_source.html#l00164">ClusterKMeansOptions::num_tries</a>.</p>

<p class="reference">Referenced by <a class="el" href="cluster-utils_8h_source.html#l00166">ClusterKMeansOptions::ClusterKMeansOptions()</a>, <a class="el" href="cluster-utils_8cc_source.html#l01194">TreeClusterer::FindBestSplit()</a>, <a class="el" href="tree_2build-tree_8cc_source.html#l00748">kaldi::KMeansClusterPhones()</a>, <a class="el" href="diag-gmm_8cc_source.html#l00231">DiagGmm::MergeKmeans()</a>, <a class="el" href="cluster-utils-test_8cc_source.html#l00328">kaldi::TestClusterKMeans()</a>, and <a class="el" href="cluster-utils-test_8cc_source.html#l00387">kaldi::TestClusterKMeansVector()</a>.</p>
<div class="fragment"><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;                                                  {</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;  <span class="keywordflow">if</span> (points.size() == 0) {</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;    <span class="keywordflow">if</span> (clusters_out) <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(clusters_out-&gt;empty());  <span class="comment">// or we wouldn&#39;t know whether to free the pointers.</span></div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;    <span class="keywordflow">if</span> (assignments_out) assignments_out-&gt;clear();</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    <span class="keywordflow">return</span> 0.0;</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;  }</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;  <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(cfg.num_tries&gt;=1 &amp;&amp; cfg.num_iters&gt;=1);</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;  <span class="keywordflow">if</span> (clusters_out) <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(clusters_out-&gt;empty());  <span class="comment">// or we wouldn&#39;t know whether to deallocate.</span></div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;  <span class="keywordflow">if</span> (cfg.num_tries == 1) {</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;    std::vector&lt;int32&gt; assignments;</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacekaldi.html#a641f628b25403274fd21dce833b95cc7">ClusterKMeansOnce</a>(points, num_clust, clusters_out, (assignments_out != NULL?assignments_out:&amp;assignments), cfg);</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;  } <span class="keywordflow">else</span> {  <span class="comment">// multiple tries.</span></div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;    <span class="keywordflow">if</span> (clusters_out) {</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;      <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(clusters_out-&gt;empty());  <span class="comment">// we don&#39;t know the ownership of any pointers in there, otherwise.</span></div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;    }</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;    <a class="code" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> best_ans = 0.0;</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;    <span class="keywordflow">for</span> (int32 <a class="code" href="namespacernnlm.html#acb559820d9ca11295b4500f179ef6392">i</a> = 0;<a class="code" href="namespacernnlm.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; cfg.num_tries;<a class="code" href="namespacernnlm.html#acb559820d9ca11295b4500f179ef6392">i</a>++) {</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;      std::vector&lt;Clusterable*&gt; clusters_tmp;</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;      std::vector&lt;int32&gt; assignments_tmp;</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;      <a class="code" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> ans = <a class="code" href="namespacekaldi.html#a641f628b25403274fd21dce833b95cc7">ClusterKMeansOnce</a>(points, num_clust, &amp;clusters_tmp, &amp;assignments_tmp, cfg);</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;      <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(!<a class="code" href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">ContainsNullPointers</a>(clusters_tmp));</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="namespacernnlm.html#acb559820d9ca11295b4500f179ef6392">i</a> == 0 || ans &gt; best_ans) {</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;        best_ans = ans;</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;        <span class="keywordflow">if</span> (clusters_out) {</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;          <span class="keywordflow">if</span> (clusters_out-&gt;size()) <a class="code" href="namespacekaldi.html#a34158c6c567bc6c51c90af0251395d6a">DeletePointers</a>(clusters_out);</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;          *clusters_out = clusters_tmp;</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;          clusters_tmp.clear();  <span class="comment">// suppress deletion of pointers.</span></div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;        }</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;        <span class="keywordflow">if</span> (assignments_out) *assignments_out = assignments_tmp;</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;      }</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;      <span class="comment">// delete anything remaining in clusters_tmp (we cleared it if we used</span></div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;      <span class="comment">// the pointers.</span></div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;      <a class="code" href="namespacekaldi.html#a34158c6c567bc6c51c90af0251395d6a">DeletePointers</a>(&amp;clusters_tmp);</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;    }</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;    <span class="keywordflow">return</span> best_ans;</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;  }</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;}</div><div class="ttc" id="namespacekaldi_html_a34158c6c567bc6c51c90af0251395d6a"><div class="ttname"><a href="namespacekaldi.html#a34158c6c567bc6c51c90af0251395d6a">kaldi::DeletePointers</a></div><div class="ttdeci">void DeletePointers(std::vector&lt; A *&gt; *v)</div><div class="ttdoc">Deletes any non-NULL pointers in the vector v, and sets the corresponding entries of v to NULL...</div><div class="ttdef"><b>Definition:</b> <a href="stl-utils_8h_source.html#l00186">stl-utils.h:186</a></div></div>
<div class="ttc" id="namespacekaldi_html_a8b1bd2bab67151dfdf3acbe70b8341f1"><div class="ttname"><a href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">kaldi::ContainsNullPointers</a></div><div class="ttdeci">bool ContainsNullPointers(const std::vector&lt; A *&gt; &amp;v)</div><div class="ttdoc">Returns true if the vector of pointers contains NULL pointers. </div><div class="ttdef"><b>Definition:</b> <a href="stl-utils_8h_source.html#l00199">stl-utils.h:199</a></div></div>
<div class="ttc" id="namespacekaldi_html_a641f628b25403274fd21dce833b95cc7"><div class="ttname"><a href="namespacekaldi.html#a641f628b25403274fd21dce833b95cc7">kaldi::ClusterKMeansOnce</a></div><div class="ttdeci">BaseFloat ClusterKMeansOnce(const std::vector&lt; Clusterable *&gt; &amp;points, int32 num_clust, std::vector&lt; Clusterable *&gt; *clusters_out, std::vector&lt; int32 &gt; *assignments_out, ClusterKMeansOptions &amp;cfg)</div><div class="ttdoc">ClusterKMeansOnce is called internally by ClusterKMeans; it is equivalent to calling ClusterKMeans wi...</div><div class="ttdef"><b>Definition:</b> <a href="cluster-utils_8cc_source.html#l00918">cluster-utils.cc:918</a></div></div>
<div class="ttc" id="namespacekaldi_html_aa66ff8367094543664b3b6a13d77c139"><div class="ttname"><a href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">kaldi::BaseFloat</a></div><div class="ttdeci">float BaseFloat</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-types_8h_source.html#l00029">kaldi-types.h:29</a></div></div>
<div class="ttc" id="namespacernnlm_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="namespacernnlm.html#acb559820d9ca11295b4500f179ef6392">rnnlm::i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="mikolov-rnnlm-lib_8cc_source.html#l00066">mikolov-rnnlm-lib.cc:66</a></div></div>
<div class="ttc" id="group__error__group_html_gad5710173d69cddcda4fa21ded3c77f16"><div class="ttname"><a href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a></div><div class="ttdeci">#define KALDI_ASSERT(cond)</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-error_8h_source.html#l00168">kaldi-error.h:168</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gae6c80e7da6b44a697295be2de67ea1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6c80e7da6b44a697295be2de67ea1e7">&#9670;&nbsp;</a></span>ClusterTopDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> ClusterTopDown </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>max_clust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>clusters_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32 &gt; *&#160;</td>
          <td class="paramname"><em>assignments_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkaldi_1_1TreeClusterOptions.html">TreeClusterOptions</a>&#160;</td>
          <td class="paramname"><em>cfg</em> = <code><a class="el" href="structkaldi_1_1TreeClusterOptions.html">TreeClusterOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A clustering algorithm that internally uses TreeCluster, but does not give you the information about the structure of the tree. </p>
<p>The "clusters_out" and "assignments_out" may be NULL if the outputs are not needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[in] points to be clustered (must be all non-NULL). </td></tr>
    <tr><td class="paramname">max_clust</td><td>[in] Maximum number of clusters (you will get exactly this number, if there are at least this many points, except if you set the cfg.thresh value nonzero, in which case that threshold may limit the number of clusters. </td></tr>
    <tr><td class="paramname">clusters_out</td><td>[out] may be NULL; if non-NULL, should be empty when called. Will be set to a vector of statistics corresponding to the output clusters. </td></tr>
    <tr><td class="paramname">assignments_out</td><td>[out] may be NULL; if non-NULL, will be set to a vector of same size as "points", which says for each point which cluster it is assigned to. </td></tr>
    <tr><td class="paramname">cfg</td><td>[in] Configuration object that controls clustering behavior. Most important value is "thresh", which provides an alternative mechanism [other than max_clust] to limit the number of leaves. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cluster-utils_8cc_source.html#l01261">1261</a> of file <a class="el" href="cluster-utils_8cc_source.html">cluster-utils.cc</a>.</p>

<p class="reference">References <a class="el" href="mikolov-rnnlm-lib_8cc_source.html#l00066">rnnlm::j</a>, and <a class="el" href="cluster-utils_8cc_source.html#l01240">kaldi::TreeCluster()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cluster-utils-test_8cc_source.html#l00508">kaldi::TestClusterTopDown()</a>, and <a class="el" href="cluster-utils_8h_source.html#l00213">TreeClusterOptions::TreeClusterOptions()</a>.</p>
<div class="fragment"><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;                                                 {</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;  int32 num_leaves = 0;</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;  <a class="code" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> ans = <a class="code" href="group__clustering__group__algo.html#gad2937c106b02a420e044390b465014fa">TreeCluster</a>(points, max_clust, clusters_out, assignments_out, NULL, &amp;num_leaves, cfg);</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;  <span class="keywordflow">if</span> (clusters_out != NULL) {</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="namespacernnlm.html#a37d972ae0b47b9099e30983131d31916">j</a> = num_leaves;<a class="code" href="namespacernnlm.html#a37d972ae0b47b9099e30983131d31916">j</a>&lt;clusters_out-&gt;size();<a class="code" href="namespacernnlm.html#a37d972ae0b47b9099e30983131d31916">j</a>++) <span class="keyword">delete</span> (*clusters_out)[<a class="code" href="namespacernnlm.html#a37d972ae0b47b9099e30983131d31916">j</a>];</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;    clusters_out-&gt;resize(num_leaves);  <span class="comment">// number of leaf-level clusters in tree.</span></div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;  }</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;  <span class="keywordflow">return</span> ans;</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;}</div><div class="ttc" id="namespacernnlm_html_a37d972ae0b47b9099e30983131d31916"><div class="ttname"><a href="namespacernnlm.html#a37d972ae0b47b9099e30983131d31916">rnnlm::j</a></div><div class="ttdeci">int j</div><div class="ttdef"><b>Definition:</b> <a href="mikolov-rnnlm-lib_8cc_source.html#l00066">mikolov-rnnlm-lib.cc:66</a></div></div>
<div class="ttc" id="namespacekaldi_html_aa66ff8367094543664b3b6a13d77c139"><div class="ttname"><a href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">kaldi::BaseFloat</a></div><div class="ttdeci">float BaseFloat</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-types_8h_source.html#l00029">kaldi-types.h:29</a></div></div>
<div class="ttc" id="group__clustering__group__algo_html_gad2937c106b02a420e044390b465014fa"><div class="ttname"><a href="group__clustering__group__algo.html#gad2937c106b02a420e044390b465014fa">kaldi::TreeCluster</a></div><div class="ttdeci">BaseFloat TreeCluster(const std::vector&lt; Clusterable *&gt; &amp;points, int32 max_clust, std::vector&lt; Clusterable *&gt; *clusters_out, std::vector&lt; int32 &gt; *assignments_out, std::vector&lt; int32 &gt; *clust_assignments_out, int32 *num_leaves_out, TreeClusterOptions cfg)</div><div class="ttdoc">TreeCluster is a top-down clustering algorithm, using a binary tree (not necessarily balanced)...</div><div class="ttdef"><b>Definition:</b> <a href="cluster-utils_8cc_source.html#l01240">cluster-utils.cc:1240</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gabc769f73ac32a09d383bfbd139f6326b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc769f73ac32a09d383bfbd139f6326b">&#9670;&nbsp;</a></span>RefineClusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> RefineClusters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32 &gt; *&#160;</td>
          <td class="paramname"><em>assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkaldi_1_1RefineClustersOptions.html">RefineClustersOptions</a>&#160;</td>
          <td class="paramname"><em>cfg</em> = <code><a class="el" href="structkaldi_1_1RefineClustersOptions.html">RefineClustersOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RefineClusters is mainly used internally by other clustering algorithms. </p>
<p>It starts with a given assignment of points to clusters and keeps trying to improve it by moving points from cluster to cluster, up to a maximum number of iterations.</p>
<p>"clusters" and "assignments" are both input and output variables, and so both MUST be non-NULL.</p>
<p>"top_n" (&gt;=2) is a pruning value: more is more exact, fewer is faster. The algorithm initially finds the "top_n" closest clusters to any given point, and from that point only consider move to those "top_n" clusters. Since RefineClusters is called multiple times from ClusterKMeans (for instance), this is not really a limitation. </p>

<p class="definition">Definition at line <a class="el" href="cluster-utils_8cc_source.html#l00895">895</a> of file <a class="el" href="cluster-utils_8cc_source.html">cluster-utils.cc</a>.</p>

<p class="reference">References <a class="el" href="stl-utils_8h_source.html#l00199">kaldi::ContainsNullPointers()</a>, <a class="el" href="kaldi-error_8h_source.html#l00168">KALDI_ASSERT</a>, <a class="el" href="cluster-utils_8h_source.html#l00130">RefineClustersOptions::num_iters</a>, and <a class="el" href="cluster-utils_8cc_source.html#l00721">RefineClusterer::Refine()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cluster-utils_8cc_source.html#l00918">kaldi::ClusterKMeansOnce()</a>, <a class="el" href="build-tree-utils_8cc_source.html#l00348">kaldi::FindBestSplitForKey()</a>, <a class="el" href="cluster-utils_8h_source.html#l00133">RefineClustersOptions::RefineClustersOptions()</a>, and <a class="el" href="cluster-utils-test_8cc_source.html#l00285">kaldi::TestRefineClusters()</a>.</p>
<div class="fragment"><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;                                                    {</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;<span class="preprocessor">#ifndef KALDI_PARANOID // don&#39;t do this check in &quot;paranoid&quot; mode as we want to expose bugs.</span></div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;  <span class="keywordflow">if</span> (cfg.num_iters &lt;= 0) { <span class="keywordflow">return</span> 0.0; } <span class="comment">// nothing to do.</span></div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;  <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(clusters != NULL &amp;&amp; assignments != NULL);</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;  <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(!<a class="code" href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">ContainsNullPointers</a>(points) &amp;&amp; !<a class="code" href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">ContainsNullPointers</a>(*clusters));</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;  RefineClusterer rc(points, clusters, assignments, cfg);</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;  <a class="code" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> ans = rc.Refine();</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;  <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(!<a class="code" href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">ContainsNullPointers</a>(*clusters));</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;  <span class="keywordflow">return</span> ans;</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;}</div><div class="ttc" id="namespacekaldi_html_a8b1bd2bab67151dfdf3acbe70b8341f1"><div class="ttname"><a href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">kaldi::ContainsNullPointers</a></div><div class="ttdeci">bool ContainsNullPointers(const std::vector&lt; A *&gt; &amp;v)</div><div class="ttdoc">Returns true if the vector of pointers contains NULL pointers. </div><div class="ttdef"><b>Definition:</b> <a href="stl-utils_8h_source.html#l00199">stl-utils.h:199</a></div></div>
<div class="ttc" id="namespacekaldi_html_aa66ff8367094543664b3b6a13d77c139"><div class="ttname"><a href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">kaldi::BaseFloat</a></div><div class="ttdeci">float BaseFloat</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-types_8h_source.html#l00029">kaldi-types.h:29</a></div></div>
<div class="ttc" id="group__error__group_html_gad5710173d69cddcda4fa21ded3c77f16"><div class="ttname"><a href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a></div><div class="ttdeci">#define KALDI_ASSERT(cond)</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-error_8h_source.html#l00168">kaldi-error.h:168</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gad2937c106b02a420e044390b465014fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2937c106b02a420e044390b465014fa">&#9670;&nbsp;</a></span>TreeCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> TreeCluster </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>max_clust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classkaldi_1_1Clusterable.html">Clusterable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>clusters_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32 &gt; *&#160;</td>
          <td class="paramname"><em>assignments_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32 &gt; *&#160;</td>
          <td class="paramname"><em>clust_assignments_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>num_leaves_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkaldi_1_1TreeClusterOptions.html">TreeClusterOptions</a>&#160;</td>
          <td class="paramname"><em>cfg</em> = <code><a class="el" href="structkaldi_1_1TreeClusterOptions.html">TreeClusterOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TreeCluster is a top-down clustering algorithm, using a binary tree (not necessarily balanced). </p>
<p>Returns objf improvement versus having all points in one cluster. The algorithm is:</p><ul>
<li>Initialize to 1 cluster (tree with 1 node).</li>
<li>Maintain, for each cluster, a "best-binary-split" (using ClusterKMeans to do so). Always split the highest scoring cluster, until we can do no more splits.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>[in] Data points to be clustered </td></tr>
    <tr><td class="paramname">max_clust</td><td>[in] Maximum number of clusters (you will get exactly this number, if there are at least this many points, except if you set the cfg.thresh value nonzero, in which case that threshold may limit the number of clusters. </td></tr>
    <tr><td class="paramname">clusters_out</td><td>[out] If non-NULL, will be set to the a vector whose first (*num_leaves_out) elements are the leaf clusters, and whose subsequent elements are the nonleaf nodes in the tree, in topological order with the root node last. Must be empty vector when this function is called. </td></tr>
    <tr><td class="paramname">assignments_out</td><td>[out] If non-NULL, will be set to a vector to a vector the same size as "points", where assignments[i] is the leaf node index i to which the i'th point gets clustered. </td></tr>
    <tr><td class="paramname">clust_assignments_out</td><td>[out] If non-NULL, will be set to a vector the same size as clusters_out which says for each node (leaf or nonleaf), the index of its parent. For the root node (which is last), assignments_out[i] == i. For each i, assignments_out[i]&gt;=i, i.e. any node's parent is higher numbered than itself. If you don't need this information, consider using instead the ClusterTopDown function. </td></tr>
    <tr><td class="paramname">num_leaves_out</td><td>[out] If non-NULL, will be set to the number of leaf nodes in the tree. </td></tr>
    <tr><td class="paramname">cfg</td><td>[in] Configuration object that controls clustering behavior. Most important value is "thresh", which provides an alternative mechanism [other than max_clust] to limit the number of leaves. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cluster-utils_8cc_source.html#l01240">1240</a> of file <a class="el" href="cluster-utils_8cc_source.html">cluster-utils.cc</a>.</p>

<p class="reference">References <a class="el" href="cluster-utils_8cc_source.html#l01042">TreeClusterer::Cluster()</a>, <a class="el" href="stl-utils_8h_source.html#l00199">kaldi::ContainsNullPointers()</a>, and <a class="el" href="kaldi-error_8h_source.html#l00168">KALDI_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="tree_2build-tree_8cc_source.html#l00615">kaldi::AutomaticallyObtainQuestions()</a>, <a class="el" href="regression-tree_8cc_source.html#l00034">RegressionTree::BuildTree()</a>, <a class="el" href="cluster-utils_8cc_source.html#l01261">kaldi::ClusterTopDown()</a>, <a class="el" href="cluster-utils-test_8cc_source.html#l00460">kaldi::TestTreeCluster()</a>, and <a class="el" href="cluster-utils_8h_source.html#l00213">TreeClusterOptions::TreeClusterOptions()</a>.</p>
<div class="fragment"><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;                                              {</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;  <span class="keywordflow">if</span> (points.size() == 0) {</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;    <span class="keywordflow">if</span> (clusters_out) clusters_out-&gt;clear();</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;    <span class="keywordflow">if</span> (assignments_out) assignments_out-&gt;clear();</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;    <span class="keywordflow">if</span> (clust_assignments_out) clust_assignments_out-&gt;clear();</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;    <span class="keywordflow">if</span> (num_leaves_out) *num_leaves_out = 0;</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;    <span class="keywordflow">return</span> 0.0;</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;  }</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;  TreeClusterer tc(points, max_clust, cfg);</div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;  <a class="code" href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">BaseFloat</a> ans = tc.Cluster(clusters_out, assignments_out, clust_assignments_out, num_leaves_out);</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;  <span class="keywordflow">if</span> (clusters_out) <a class="code" href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a>(!<a class="code" href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">ContainsNullPointers</a>(*clusters_out));</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;  <span class="keywordflow">return</span> ans;</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;}</div><div class="ttc" id="namespacekaldi_html_a8b1bd2bab67151dfdf3acbe70b8341f1"><div class="ttname"><a href="namespacekaldi.html#a8b1bd2bab67151dfdf3acbe70b8341f1">kaldi::ContainsNullPointers</a></div><div class="ttdeci">bool ContainsNullPointers(const std::vector&lt; A *&gt; &amp;v)</div><div class="ttdoc">Returns true if the vector of pointers contains NULL pointers. </div><div class="ttdef"><b>Definition:</b> <a href="stl-utils_8h_source.html#l00199">stl-utils.h:199</a></div></div>
<div class="ttc" id="namespacekaldi_html_aa66ff8367094543664b3b6a13d77c139"><div class="ttname"><a href="namespacekaldi.html#aa66ff8367094543664b3b6a13d77c139">kaldi::BaseFloat</a></div><div class="ttdeci">float BaseFloat</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-types_8h_source.html#l00029">kaldi-types.h:29</a></div></div>
<div class="ttc" id="group__error__group_html_gad5710173d69cddcda4fa21ded3c77f16"><div class="ttname"><a href="group__error__group.html#gad5710173d69cddcda4fa21ded3c77f16">KALDI_ASSERT</a></div><div class="ttdeci">#define KALDI_ASSERT(cond)</div><div class="ttdef"><b>Definition:</b> <a href="kaldi-error_8h_source.html#l00168">kaldi-error.h:168</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
