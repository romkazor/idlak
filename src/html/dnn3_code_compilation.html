<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Kaldi: Compilation in the &quot;nnet3&quot; setup</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 <td id="projectlogo"><a href="http://kaldi-asr.org/"><img alt="Logo" src="KaldiTextAndLogoSmall.png"/ style="padding: 3px 5px 1px 5px"></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname" style="display:none">Kaldi
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief" style="display:none"></div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dnn3_code_compilation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Compilation in the "nnet3" setup </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="dnn3_code_compilation_intro"></a>
Introduction</h1>
<p>This page covers the compilation process in the "nnet3" setup. It will generally only be of interest to those who want to understand the internals of the framework.</p>
<ul>
<li>Up: <a class="el" href="dnn3.html">The "nnet3" setup</a>.</li>
<li>Previous: <a class="el" href="dnn3_code_data_types.html">Data types in the "nnet3" setup.</a></li>
<li>Next: <a class="el" href="dnn3_code_optimization.html">Optimization in the "nnet3" setup</a></li>
</ul>
<h1><a class="anchor" id="dnn3_compile_overview"></a>
Overview of compilation</h1>
<p>We assume that the reader is familiar with the data types introduced in <a class="el" href="dnn3_code_data_types.html">Data types in the "nnet3" setup.</a>. The compilation process is something that takes as input an <a class="el" href="classkaldi_1_1nnet3_1_1Nnet.html">Nnet</a> and a <a class="el" href="structkaldi_1_1nnet3_1_1ComputationRequest.html">ComputationRequest</a>, and outputs a <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html">NnetComputation</a>. The <a class="el" href="structkaldi_1_1nnet3_1_1ComputationRequest.html">ComputationRequest</a> includes a representation of what output indexes are requested and what input indexes are available; the reason why we don't just supply the output indexes and let the compiler work out what input indexes are required, is that some networks such as RNNs may consume an arbitrary amount of input to produce a given output.</p>
<p>Something that might be considered a part of the compilation process, but which we discuss in a separate page, is code optimization: see <a class="el" href="dnn3_code_optimization.html">Optimization in the "nnet3" setup</a>.</p>
<p>This page covers:</p><ul>
<li><a class="el" href="dnn3_code_compilation.html#dnn3_compile_graph">Creating the computation graph</a></li>
<li><a class="el" href="dnn3_code_compilation.html#dnn3_compile_steps">Organizing the computation into steps</a></li>
<li><a class="el" href="dnn3_code_compilation.html#dnn3_compile_compiler">Class Compiler</a></li>
</ul>
<h1><a class="anchor" id="dnn3_compile_graph"></a>
Creating the computation graph</h1>
<h2><a class="anchor" id="dnn3_compile_graph_graph"></a>
Details of ComputationGraph</h2>
<p>We previously gave a brief introduction to struct <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a>, but here we provide a few more details. Remember that the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a> maps back and forth between Cindexes and integer cindex_ids for efficiency. We show just the data members of <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a> here (remember that in C++, a struct is just a class whose members are public by default): </p><pre class="fragment">struct ComputationGraph {
  // The mapping of cindex_id to Cindex.
  std::vector&lt;Cindex&gt; cindexes;

  // For each Cindex this tells us whether it was provided as an input to the
  // computation.
  std::vector&lt;bool&gt; is_input;

  // dependencies[cindex_id] gives you the list of other cindex_ids that this
  // particular cindex_id directly depends on to compute it.
  std::vector&lt;std::vector&lt;int32&gt; &gt; dependencies;
private:
  // Maps each Cindex to an integer cindex_id: reverse mapping of "cindexes".
  // Must be accessed via the GetCindexId() function.
  unordered_map&lt;Cindex, int32, CindexHasher&gt; cindex_to_cindex_id_;
};
</pre><p> The most important thing is that a <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a> maps back and forth between Cindexes and cindex_ids (integers), and stores a list of "dependencies", saying for each cindex_id which other cindex_ids are required to compute it. The exact meaning of "dependencies" depends on the stage of the compilation. At early stages it contains all cindex_ids corresponding to Cindexes that were returned by the <a class="el" href="classkaldi_1_1nnet3_1_1Descriptor.html#a06c7efb3516b383368169ff93da74777">GetDependencies()</a> function of class <a class="el" href="classkaldi_1_1nnet3_1_1Descriptor.html">Descriptor</a>. Later on it is pruned back to only those dependencies that are actually used in the computation. Note that Components also have a similar GetDependencies() function, and an <a class="el" href="classkaldi_1_1nnet3_1_1Component.html#a529c07610dd915a30e452f80b8bb5fc0">IsComputable()</a> function, like Descriptors. However, this only does someathing interesting in the case of non-simple Components.</p>
<p>The <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a> also has a vector "is_input", saying whether each cindex_id is an input to the computation. This might seem redundant, because we could just look up whether its node is of type kInput. It is needed because we have actually designed the framework so that you can provide previously computed values of nodes of type kComponent: this has an envisaged use in online decoding for speech recognition with things like RNNs.</p>
<h2><a class="anchor" id="dnn3_compile_graph_building"></a>
Building the ComputationGraph</h2>
<h3><a class="anchor" id="dnn3_compile_graph_building_intro"></a>
Introduction</h3>
<p>Class <a class="el" href="classkaldi_1_1nnet3_1_1ComputationGraphBuilder.html" title="An abstract representation of a set of Cindexes. ">ComputationGraphBuilder</a> is responsible for building the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a>. In the simple case where there are no optional dependencies, the process is quite simple. (By optional dependencies, we mean descriptors with <code>Failover(X,Y)</code> or <code>IfDefined(X)</code>, or certain non-simple Components). The simple version of the process is that we start with requested outputs of the network, compute their dependencies and add them to the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a>, and keep working backward adding dependencies until we hit input nodes. At that point, hopefully all Cindexes we require at input nodes are ones that have been supplied in the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationRequest.html">ComputationRequest</a>; if they are not supplied, we would have to say that the computation is not possible.</p>
<h3><a class="anchor" id="dnn3_compile_graph_building_basic"></a>
Basic algorithm</h3>
<p>Here we describe a basic algorithm which is <em>not</em> what we use but which serves to motivate the actual algorithm. While building the computation graph we need to be able to work out whether each Cindex is computable from supplied inputs. (We will use the terms Cindex and cindex_id fairly interchangeably, because there is a one-to-one mapping). One simple and natural and algorithm would be as follows:</p><ul>
<li>First follow back all possible dependencies from the output using the <code>GetDependencies()</code> functions of Descriptors and Components.</li>
<li>In the opposite direction, starting from the input, work out which Cindexes are computable (using <code>IsComputable()</code>), and prune back the dependencies to just those that participate in the computation.</li>
<li>Check that all requested outputs were computable.</li>
<li>Prune away all cindex_ids that are not actually necessary to compute the outputs.</li>
</ul>
<p>However, this algorithm wouldn't work in all cases of interest, for instance RNNs. The problem is that the first phase (following back all possible dependencies) would run forever, with t approaching -.</p>
<h3><a class="anchor" id="dnn3_compile_graph_building_idea"></a>
Motivation for the algorithm we use</h3>
<p>Instead we need a slightly more sophisticated algorithm. We haven't proven that this algorithm would always terminate in all possible cases of interest, but it seems likely to terminate in all the cases we have in mind. Consider the case of an RNN where some recurrent layer has a dependency that goes back to time t-1, and the input starts at t = 0. Following dependencies will take t all the way back to -, but we should be able to figure out that those hidden-layer Cindexes for negative t are never going to participate in the computation, because if we follow <em>their</em> dependencies back to the input we will see that the corresponding inputs were not supplied, so they are not computable. The way we make use of this to avoid recursing to - is to note that if a Cindex is not computable, there is no point following its dependencies back because we know they will never be used. The problem is that this is a chicken-and-egg situation because before we process the dependencies of a Cindex we don't <em>know</em> that it's not computable.</p>
<h3><a class="anchor" id="dnn3_compile_graph_building_real"></a>
The algorithm we use</h3>
<p>The way we solve this problem is as follows. We assign to each Cindex an enum <a class="el" href="classkaldi_1_1nnet3_1_1ComputationGraphBuilder.html#a4da89c69c9a5840ecaa70959af36c492">ComputableInfo</a>, defined as: </p><pre class="fragment">  enum ComputableInfo {
    kUnknown = 0,
    kComputable = 1,
    kNotComputable = 2,
    kWillNotCompute = 3
  };
</pre><p> whose meaning is as follows:</p><ul>
<li>kUnknown: we are not yet sure whether this Cindex is computable</li>
<li>kComputable: we know that this Cindex is computable</li>
<li>kNotComputable: we know that this Cindex is not computable</li>
<li>kWillNotCompute: we are not going to compute this Cindex regardless of whether it's computable, because we have determined that it is not usable. Treated the same as kNotComputable for most purposes.The way we determine whether a Cindex is usable is as follows. We assign to each Cindex an integer <a class="el" href="classkaldi_1_1nnet3_1_1ComputationGraphBuilder.html#a352e1ae42322806ca36968c7d3ff9f31">usable_count</a> which functions a little like a reference-count in memory management. If the <a class="el" href="classkaldi_1_1nnet3_1_1ComputationGraphBuilder.html#a352e1ae42322806ca36968c7d3ff9f31">usable_count</a> for a Cindex is &gt;0, it means that that that Cindex might possibly partipate in the final computation. We ensure that the <a class="el" href="classkaldi_1_1nnet3_1_1ComputationGraphBuilder.html#a352e1ae42322806ca36968c7d3ff9f31">usable_count</a> always has a value determined by the following rules:</li>
<li>1 if this Cindex is a requested output in the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationRequest.html">ComputationRequest</a>. Otherwise..</li>
<li>The number of other Cindexes j such that:<ul>
<li>The ComputableInfo of j is not kNotComputable, and</li>
<li>The usable_count of j is greater than zero, and</li>
<li>This Cindex is a dependency of j in the computation graph.</li>
</ul>
</li>
</ul>
<p>The way we avoid infinitely recursing in the processing of dependencies is that if the usable_count of a Cindex is zero we set its state to kWillNotCompute and then we refrain from adding its dependencies to the computation graph. For this to work, we make sure to process the dependencies in breadth-first order: that is, we process dependencies at one hop from the output, then two hops from the output, and so on. This avoids the case where, in the RNN, we might process the hidden layer all the way back to t = - before noticing that the corresponding inputs were not available.</p>
<p>Class <a class="el" href="classkaldi_1_1nnet3_1_1ComputationGraphBuilder.html" title="An abstract representation of a set of Cindexes. ">ComputationGraphBuilder</a> maintains two queues: one for Cindexes that we haven't yet added their dependencies to the graph, and one (<a class="el" href="classkaldi_1_1nnet3_1_1ComputationGraphBuilder.html#a66766d6e81dab27225b1d99fa891b0be">computable_queue_</a>) for Cindexes such that we need to re-evaluate whether they are computable (i.e. update their ComputableInfo). When the ComputableInfo of a Cindex changes, we need to re-check the ComputableInfo of Cindexes that depend on it, and to do so we add them to <a class="el" href="classkaldi_1_1nnet3_1_1ComputationGraphBuilder.html#a66766d6e81dab27225b1d99fa891b0be">computable_queue_</a>.</p>
<h3><a class="anchor" id="dnn3_compile_graph_building_interface"></a>
Interface of ComputationGraphBuilder</h3>
<p>We list the most important parts of the public interface of <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a> Builder below; it should be quite self-explanatory. </p><pre class="fragment">class ComputationGraphBuilder {
 public:
  ComputationGraphBuilder(const Nnet &amp;nnet,
                          const ComputationRequest &amp;request,
                          ComputationGraph *graph);
  // Does the initial computation (populating the graph and computing
  // whether each required cindex_id is computable), without the pruning.
  void Compute();
  // Returns true if all requested outputs are computable.  To be called after
  // Compute() but before Prune(().
  bool AllOutputsAreComputable();
  // Removed unused Cinndexes from the graph.
  void Prune();
  ...
};
</pre><h1><a class="anchor" id="dnn3_compile_steps"></a>
Organizing the computation into steps</h1>
<h2><a class="anchor" id="dnn3_compile_steps_intro"></a>
Introduction to steps</h2>
<p>Once we have the computation graph, we have enough information in principle to execute the computation without doing much more work. We could sort the Cindexes in topological order in the computation graph, and individually evaluate each Cindex using its dependencies as inputs. Unfortunately this wouldn't be very efficient because matrix operations don't reach their full efficiency unless they are operating on quite large matrices; this is particularly true when using GPUs. So what we want to do is to group the Cindexes into batches such that the Cindexes in the same batch can all be computed at the same time. This batch is going to be called a "step", and it will roughly correspond to one command in the <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html">NnetComputation</a>.</p>
<p>We are going to arrange the set of all cindex_ids in the computation into a sequence of steps, with the following properties:</p><ul>
<li>All cindex_ids within a given step correspond to the same node in the graph</li>
<li>All dependencies of cindex_ids within a given step have been computed in earlier steps.</li>
</ul>
<p>There are also some extra, more obscure properties that the sequence of steps must satisfy:</p><ul>
<li>(a) Any input or output in the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationRequest.html">ComputationRequest</a> must be in one step, with the Indexes in the same order as specified in the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationRequest.html">ComputationRequest</a>. (Note: inputs can be for nodes of type kComponent as well as kInput).</li>
<li>(b) If a step corresponds to a node of type kComponent (and does not correspond to an input in the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationRequest.html">ComputationRequest</a>), then the immediately preceding step must correspond to a node of type kDescriptor, and the sequence of Indexes in the two steps must be identical.</li>
<li>(c) If a step corresponds to a node of type kDimRange, then there must be another step corresponding to the source node, with exactly the same Indexes appearing in the same order. (This lets us use a sub-matrix for the kDimRange node).The reason for rule (b) is to ensure that the <a class="el" href="classkaldi_1_1nnet3_1_1Component.html" title="Abstract base-class for neural-net components. ">Component</a> can use the output of the <a class="el" href="classkaldi_1_1nnet3_1_1Descriptor.html">Descriptor</a> directly as its input, without any additional reordering or regrouping (since such reordering and regrouping is, by design, the responsibility of the Descriptors). Because of this rule, it is possible in principle for a cindex_id from a node of type kDescriptor to appear separately in more than one different step, although this could only happen if we were using non-simple Components. Also, to ensure that rule (c) is satisfied we may occasionally have to add new cindex_ids to the computation graph.</li>
</ul>
<h2><a class="anchor" id="dnn3_compile_steps_creating"></a>
Creating the sequence of steps (basic algorithm)</h2>
<p>Here we describe a basic algorithm for creating the sequence of steps that we <em>do not use</em>, but will serve to motivate the actual algorithm that we'll describe later. This basic algorithm would be:</p><ul>
<li>First put aside Cindexes corresponding to input and output nodes, separate them by node-index, order within each of those steps to the same order as the ComputationRequests, and put them on the side.</li>
<li>Next process the intermediate Cindexes that are not inputs or outputs as follows:<ul>
<li>Take the remaining Cindexes and arrange them into sets called "phases" where the first phase contains all Cindexes that depend only on inputs; and in general the n'th phase contains all remaining Cindexes that depend only on quantities present in phases less than n.</li>
<li>Remove from each phase all Cindexes not corresponding to nodes of type kComponent (we'll handle kDimRange and component-input nodes later).</li>
<li>Order the steps by using the ordering operator of struct <a class="el" href="structkaldi_1_1nnet3_1_1Index.html" title="struct Index is intended to represent the various indexes by which we number the rows of the matrices...">Index</a>.</li>
<li>Create the steps for component-input nodes as follows:<ul>
<li>For each step of type kComponent, compute the set of all its dependencies using the "dependencies" member of the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a>.</li>
<li>Order them using the ordering operator of struct <a class="el" href="structkaldi_1_1nnet3_1_1Index.html" title="struct Index is intended to represent the various indexes by which we number the rows of the matrices...">Index</a>. (for simple Components this ensures they are in the same order as the output of the <a class="el" href="classkaldi_1_1nnet3_1_1Component.html" title="Abstract base-class for neural-net components. ">Component</a>).</li>
<li>(Obscure feature): non-simple Components that want to reorder their inputs are allowed to do so at this point; see <a class="el" href="classkaldi_1_1nnet3_1_1Component.html#a92fc16eadbf5faafb1aeb4b90614d691" title="This function only does something interesting for non-simple Components. ">Component::ReorderIndexes()</a>.</li>
<li>Place this step immediately before the corresponding step of the <a class="el" href="classkaldi_1_1nnet3_1_1Component.html" title="Abstract base-class for neural-net components. ">Component</a>.</li>
</ul>
</li>
<li>Create the steps for dim-range nodes as follows:<ul>
<li>Take all the Cindexes in the graph corresponding to dim-range nodes, and work out the step that their input comes from.</li>
<li>Note for each existing step the set of dim-range nodes that have an existing Cindex that gets input from that step.</li>
<li>For each existing step s, for each dim-range node that has an existing Cindex getting input from that step, create a step containing the same sequence of Indexes as step s, and place the new step immediately after step s.</li>
</ul>
</li>
</ul>
</li>
<li>Order all the steps so that inputs come first, intermediate steps come next, and output-steps come last.</li>
</ul>
<p>The problem with the algorithm described above is that it would end up splitting things into to many steps. For instance, imagine that we have a recurrent layer followed by a standard feedforward layer. The recurrent layer has to be split up into as many steps as there are time indexes, but the above algorithm would also split up the computation of the the fully-connected layer into many steps because those Cindexes become computable immediately after the corresponding Cindexes for the recurrent layer. What we want it for it to do all computation of the recurrent layer, then do the computation for the fully-connected layer in one step.</p>
<h2><a class="anchor" id="dnn3_compile_steps_creating_actual"></a>
Creating the sequence of steps (actual algorithm)</h2>
<p>In order to handle architectures like RNNs without creating an excessive number of computation steps, we first do some graph-theoretic processing on the neural network itself to determine the order in which we can process nodes in the graph. We can express the neural network itself as a directed graph on nodes, where there is an arc from node A to node B if node B ever refers to quantities from node A (see <a class="el" href="namespacekaldi_1_1nnet3.html#a679a6d66a5e4a3993124bc35597dd06b">NnetToDirectedGraph()</a>).</p>
<p>The function <a class="el" href="namespacekaldi_1_1nnet3.html#a380175b61aef188f214827ad6c2faca2">ComputeNnetComputationEpochs()</a> produces a mapping from nodes to epoch indexes, where nodes that are part of the same strongly connected component (SCC) in the graph (e.g. nodes that are part of the recurrency in an RNN) go to the same epoch, but nodes that are in an earlier epoch can always be computed first. That is, roughly the epoch will correspond to the layer index in the neural net.</p>
<p>The actual algorithm, then, produces three progressively more specific orderings of Cindexes: first epochs, then phases, then steps. We use essentially the algorithm described in the previous section, except modified to respect the division into epochs. We first call <a class="el" href="namespacekaldi_1_1nnet3.html#a2c9e85c299672aa4ef4a0c080d19b3d9">ComputeComputationPhases()</a> to divide the cindexes into phases, and then ComputeComputationSteps() which works out the actual steps.</p>
<h1><a class="anchor" id="dnn3_compile_compiler"></a>
Class Compiler</h1>
<h2><a class="anchor" id="dnn3_compile_compiler_intro"></a>
Introduction to class Compiler</h2>
<p>The <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html" title="This class creates an initial version of the NnetComputation, without any optimization or sharing of ...">Compiler</a> class has overall responsibility for turning the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationRequest.html">ComputationRequest</a>, together with an <a class="el" href="classkaldi_1_1nnet3_1_1Nnet.html">Nnet</a>, into a <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html">NnetComputation</a>. Internally it first creates a <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a> and a sequence of steps using the classes and functions we have introduced above.</p>
<p>Its public interface is very simple: </p><pre class="fragment">class Compiler {
 public:
  Compiler(const ComputationRequest &amp;request,
           const Nnet &amp;nnet);

  void CreateComputation(const CompilerOptions &amp;opts,
                         NnetComputation *computation);
  ...
};
</pre><h2><a class="anchor" id="dnn3_compile_compiler_creating"></a>
Creating the computation</h2>
<p>Most of the work of this class happens in its <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a3ba7e6700716ba8e6dfb85784922001b">CreateComputation()</a> function, and the implementation of this function is below. </p><pre class="fragment">void Compiler::CreateComputation(const CompilerOptions &amp;opts,
                                 NnetComputation *computation) {
  ComputationGraphBuilder builder(nnet_, request_, &amp;graph_);
  builder.Compute();
  builder.Prune();

  // see function declaration's comment for meaning of "phases".
  std::vector&lt;std::vector&lt;int32&gt; &gt; phases;
  ComputeComputationPhases(nnet_, graph_, &amp;phases);
  std::vector&lt;std::vector&lt;int32&gt; &gt; steps;
  ComputeComputationSteps(nnet_, request_, phases, &amp;graph_, &amp;steps);
  phases.clear();
  CreateLocationInfo(steps);
  std::vector&lt;bool&gt; deriv_needed;
  ComputeDerivNeeded(steps, &amp;deriv_needed);
  CreateStepInfo(deriv_needed, &amp;steps, computation);
  AddCommands(deriv_needed, computation);
  if (opts.output_debug_info)
    OutputDebugInfo(computation);
}
</pre><p> The commands up to ComputeComputationSteps() correspond to things that we have discussed above, and should be clear. Below we will discuss some of the remaining commands, and use them to give an overview of the compilation process.</p>
<h2><a class="anchor" id="dnn3_compile_compiler_location"></a>
Setting up the location information</h2>
<p>The function CreateLocationInfo() sets up a mapping <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a4286f6d7e1ff9117ffc8b1a57ded5efb">cindex_id_to_location_</a> that maps each cindex_id to a <em>location</em>, where a location defined as a pair (step-index, matrix-row-index). The matrix-row-index corresponds to the position of the cindex_id in the vector of cindex_ids for that step. We previously mentioned that it's possible in principle for cindex_ids corresponding to network-nodes of type kDescriptor that represent <a class="el" href="classkaldi_1_1nnet3_1_1Nnet.html#ace963c54d5f404914f1ce1953a9112c6">component inputs</a>, to exist in more than one step; this doesn't matter here, because we won't be relying on this information for component-input nodes.</p>
<p>We will be dealing with "location information" in a couple of different formats. The <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a4286f6d7e1ff9117ffc8b1a57ded5efb">cindex_id_to_location_</a> vector contains locations as pair (step-index, matrix-row-index). Elsewhere, and later on in the compilation process, we sometimes deal with what we call "submat-locations" which are pairs (submatrix-index, row-index). A submatrix-index is an index into the "submatrices" vector of the Computation. Once we have decided where the values and derivatives for each of the steps live, we will be able to compute the "submat-locations".</p>
<h2><a class="anchor" id="dnn3_compile_compiler_deriv_needed"></a>
Checking whether derivatives are needed</h2>
<p>Continuing to step line by line through the function <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a3ba7e6700716ba8e6dfb85784922001b">CreateComputation()</a>, we next encounter the lines: </p><pre class="fragment">  std::vector&lt;bool&gt; deriv_needed;
  ComputeDerivNeeded(steps, &amp;deriv_needed);
</pre><p> These compute an array that says for each step, whether we need to allocate the matrix of derivatives for the <em>output</em> of that step. The logic for the function <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#af5001f10346116df587c511fdf6d37c1">ComputeDerivNeeded()</a> is a little complicated, and we will try to explain it. Firstly, we will remind the user of the relevant aspects of struct <a class="el" href="structkaldi_1_1nnet3_1_1ComputationRequest.html">ComputationRequest</a>: </p><pre class="fragment">struct ComputationRequest {
  std::vector&lt;IoSpecification&gt; inputs;
  std::vector&lt;IoSpecification&gt; outputs;
  bool need_model_derivative;
  ...
};

struct IoSpecification {
  std::string name;
  std::vector&lt;Index&gt; indexes;
  bool has_deriv;
  ...
};
</pre><p> If <code>need_model_derivative</code> is false, and <code>has_deriv</code> is false for all inputs and outputs, then we won't be needing to allocate matrices for any derivatives at all. The detailed procedure follows. First we initialize the whole <code>need_deriv</code> vector to false. Then for each step counting upward, we use roughly the following logic. First define the steps we depend on as those that are listed in dependencies of cindex_ids in this step (we can work this out from the computation graph). Now,</p><ul>
<li>If any step we depend on needs the derivative, this step needs the derivative.</li>
<li>If this step is an input to the computation and its corresponding <code>has_deriv</code> is true (an input-derivative was requested), then we need the derivative.</li>
<li>If this step is an output of the computation and its corresponding <code>has_deriv</code> is true (an output-derivative was requested), then we need the derivative. (We need somewhere to put it, even if it will never be used).</li>
<li>If this is an updatable <a class="el" href="classkaldi_1_1nnet3_1_1Component.html" title="Abstract base-class for neural-net components. ">Component</a> node (i.e. for a <a class="el" href="classkaldi_1_1nnet3_1_1Component.html" title="Abstract base-class for neural-net components. ">Component</a> whose <a class="el" href="classkaldi_1_1nnet3_1_1Component.html#a3a4ff15fafe0c8c4885586fc2c36ca8a">Properties()</a> returns a number with the kUpdatable flag set) and the <code>need_model_derivative</code> flag of the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationRequest.html">ComputationRequest</a> is true, then we need the derivative.</li>
</ul>
<h2><a class="anchor" id="dnn3_compile_compiler_step_info"></a>
Computing the StepInfo</h2>
<p>The next line in <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a3ba7e6700716ba8e6dfb85784922001b">CreateComputation()</a>, is: </p><pre class="fragment">  CreateStepInfo(deriv_needed, &amp;steps, computation);
</pre><p> This sets up a variety of information associated with each step. Class <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html" title="This class creates an initial version of the NnetComputation, without any optimization or sharing of ...">Compiler</a> has a member <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a25bfe0118cf7458a88e685463d05f895">steps_</a>, of type <code>std::vector&lt;StepInfo&gt;</code>, which stores all this information: </p><pre class="fragment">class Compiler {
   ...
  struct StepInfo {
    int32 node_index;  // network-node index
    bool is_input;  // true if step corresponds to an input to the computation.
    int32 value;  // sub-matrix index of value that this step outputs.
    int32 deriv;  // sub-matrix index of derivative at the output of this step (or zero).
    int32 precomputed_indexes_index;  // ignore; only relevant for non-simple Components
    std::vector&lt;Index&gt; output_indexes;      // Indexes that this step outputs.
    std::vector&lt;int32&gt; output_cindex_ids;   // cindex_ids corresponding to the above.

    // If this component is of type kDescriptor (and note that the top-level
    // Descriptor is a concatenation over &gt;= 1 parts), then we set value_parts
    // to a list of submatrix-indexes, each for the corresponding part of the
    // value.  If there is only one part, it will have one element which will be
    // the same as "value".
    std::vector&lt;int32&gt; value_parts;
    // deriv_parts is as "value_parts", but for parts of the derivative (only
    // set up if deriv != 0.
    std::vector&lt;int32&gt; deriv_parts;

    // for nodes corresponding to descriptors, input_locations_list will contain
    // information about the inputs to this descriptor, telling us for each row
    // of the matrix what other matrix rows it is a summation over.  this is a
    // quantity indexed[part-index][row-index], then a list of pairs (step,
    // row-index), that we store here to avoid computing it twice in forward and
    // backprop.
    std::vector&lt;std::vector&lt;std::vector&lt;std::pair&lt;int32,int32&gt; &gt; &gt; &gt; input_locations_list;
  };
  std::vector&lt;StepInfo&gt; steps_;
  ...
};
</pre><p> We will discuss some of the members of struct <a class="el" href="structkaldi_1_1nnet3_1_1Compiler_1_1StepInfo.html">StepInfo</a>o here. The quantities <code>node_index</code> and <code>is_input</code> can be immediately computed from the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a> and computation request. Likewise, <code>output_cindex_ids</code> is just a copy of the cindex_ids that this step consists of; and <code>output_indexes</code> can be immediately computed from the <code>output_cindex_ids</code> and the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationGraph.html" title="The first step in compilation is to turn the ComputationSpecification into a ComputationGraph, where for each Cindex we have a list of other Cindexes that it depends on. ">ComputationGraph</a>. The members <code>value</code> and <code>deriv</code> are sub-matrix ids that we need to allocate for this step.</p>
<h3><a class="anchor" id="dnn3_compile_compiler_allocating"></a>
Allocating matrices and submatrices (background)</h3>
<p>Now is a good time to discuss matrix and sub-matrix indexes, and how we allocate matrix and sub-matrix indexes. A matrix index is an index into the <a class="el" href="classkaldi_1_1nnet3_1_1NnetComputer.html#abbace05f99a3c5e3d016c890e575ea36">matrices_</a> array of class <a class="el" href="classkaldi_1_1nnet3_1_1NnetComputer.html" title="class NnetComputer is responsible for executing the computation described in the &quot;computation&quot; object...">NnetComputer</a>, and also into the <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html#a47a751a8db1c9c4856d04495f80620e9">matrices</a> array of class <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html">NnetComputation</a>, (where only the size information is stored). We reserve matrix index zero for the empty matrix, or for the NULL matrix (depending on context). A submatrix index is an index <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html#acb31bf5441a137f7cbed4aeb74cb8421">submatrices</a> array of class <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html">NnetComputation</a>, and represents a particular row and column range of a particular numbered matrix. Whenever possible we prefer to use the submatrix index instead of the matrix index even if we know that it will correspond to a whole matrix, to avoid possible confusion between the two types of index.</p>
<p>Struct <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html">NnetComputation</a> has the following two functions which are used when allocating matrices and submatrices: </p><pre class="fragment">struct NnetComputation {
  ...
  int32 NewMatrix(int32 num_rows, int32 num_cols);
  int32 NewSubMatrix(int32 base_matrix, int32 dim_offset, int32 dim);
  ...
};
</pre><p> The <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html#a16ed03ea200a71de08070d77fd52ceb9">NewMatrix()</a> function allocates a new matrix and a sub-matrix referring to its entirety, and returns the sub-matrix index; the <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html#a61634eedcfea10a32bdb33bca3f94f2b">NewSubMatrix()</a> function returns a new sub-matrix corresponding to a column range of an existing matrix.</p>
<h3><a class="anchor" id="dnn3_compile_compiler_parts"></a>
Allocating matrices and submatrices for StepInfo</h3>
<p>All steps except those of type kDimRange have a matrix allocated to store their value, and if <code>has_deriv[step_index]</code> is true they also have a matrix allocated to store their derivative. The code that allocates the value matrix looks like this: </p><pre class="fragment">  this_info.value = computation-&gt;NewMatrix(num_rows, num_cols);
</pre><p> (where <code>this_info</code> is of type <a class="el" href="structkaldi_1_1nnet3_1_1Compiler_1_1StepInfo.html">StepInfo</a>). For steps of type kDimRange, the command that sets up the "value" matrix looks like this: </p><pre class="fragment">  this_info.value = computation-&gt;NewSubMatrix(steps_[input_step].value,
                                              node.dim_offset, node.dim);
</pre><p> For steps of type kDescriptor, we also need to set up sub-matrices for the different "parts" of the value and (if applicable) the derivative. Recall that a "part" corresponds to the term in the top-level <code>Append(...)</code> expression in the <a class="el" href="classkaldi_1_1nnet3_1_1Descriptor.html">Descriptor</a>; if there is no <code>Append(...)</code> then there is just one part. If there are multiple parts, the command to set up one sub-matrix looks like this: </p><pre class="fragment">  this_info.value_parts[p] = computation-&gt;NewSubMatrix(this_info.value,
                                                       cur_dim_offset,
                                                       this_dim);
</pre><h3><a class="anchor" id="dnn3_compile_compiler_locations"></a>
The input locations list</h3>
<p>For each part of a <a class="el" href="classkaldi_1_1nnet3_1_1Descriptor.html">Descriptor</a>, we also call a member-function <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a77c85c33bcf54ec797f1bd578bade7b8">ComputeInputLocationsList()</a> of class <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html" title="This class creates an initial version of the NnetComputation, without any optimization or sharing of ...">Compiler</a>: </p><pre class="fragment">  ComputeInputLocationsList(step, p,
                            &amp;(this_info.input_locations_list[p]));
</pre><p> The output of this function, <code>this_info.input_locations_list[p]</code> (<code>p</code> is the part index), is of type <code>std::vector&lt;std::vector&lt;std::pair&lt;int32, int32&gt; &gt; &gt;</code>. It is a vector that tells us where we get the data from to compute this part of the <a class="el" href="classkaldi_1_1nnet3_1_1Descriptor.html">Descriptor</a>. It is indexed first by the row-index of the matrix (which is the same as the index into the Cindexes/cindex_ids for the step), and then is a list of locations, which we defined above as (step-index, row-index). Because a <a class="el" href="classkaldi_1_1nnet3_1_1Descriptor.html">Descriptor</a> can only represent an unweighted sum over matrix rows, the <code>input_locations_list</code> actually contains all the information we need to generate the forward and backward code for it. So we won't have to deal directly with the <a class="el" href="classkaldi_1_1nnet3_1_1Descriptor.html">Descriptor</a> once we compute this quantity. Inside the code for <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a77c85c33bcf54ec797f1bd578bade7b8">ComputeInputLocationsList()</a>, you'll see the following lines: </p><pre class="fragment">    std::vector&lt;Cindex&gt; input_cindexes;
    CindexSet cindex_set(graph_);
    bool ans = descriptor.IsComputable(index, cindex_set, &amp;input_cindexes);
    KALDI_ASSERT(ans);
</pre><p> As you might recall, the <a class="el" href="classkaldi_1_1nnet3_1_1Descriptor.html#a69d01ab492a91282f4542f6304880e02">IsComputable()</a> function outputs the Cindexes that were actually used in the computation. It might seem surprising that we have to call this, instead of just relying on the dependencies listed in the computation graph. The reason is that the dependencies are listed for each Cindex, but we want only the dependencies for one <em>part</em> of a Cindex, and in the graph they are not broken down in that way.</p>
<h2><a class="anchor" id="dnn3_compile_compiler_input_output_info"></a>
Computing the input_output_info</h2>
<p>The next step in the code of <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a3ba7e6700716ba8e6dfb85784922001b">CreateComputation()</a> is: </p><pre class="fragment">  AddCommands(deriv_needed, computation);
</pre><p> However, a lot of things happen inside <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a218321cdd5637631bb8fc7b2eee008b3">AddCommands()</a>, so we'll go through some lines of that function. It starts off this way: </p><pre class="fragment">void Compiler::AddCommands(const std::vector&lt;bool&gt; &amp;deriv_needed,
                           NnetComputation *computation) {
  SetInputOutputInfo(computation);
  ...
</pre><p> The function SetInputOutputInfo is responsible for setting up the following member of struct <a class="el" href="structkaldi_1_1nnet3_1_1NnetComputation.html">NnetComputation</a>: </p><pre class="fragment">  unordered_map&lt;int32, std::pair&lt;int32, int32&gt; &gt; input_output_info;
</pre><p> This contains information about where the inputs and outputs of the network live (and their corresponding derivatives, if applicable). It is a map from node-index to pair (value-matrix-index, derivative-matrix-index).</p>
<h2><a class="anchor" id="dnn3_compile_compiler_allocate"></a>
Allocating the matrices</h2>
<p>Skipping a couple of minor things, the next function call in <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a218321cdd5637631bb8fc7b2eee008b3">AddCommands()</a> is: </p><pre class="fragment">  AllocateMatrices(computation);
</pre><p> This function adds commands to the computation, to allocate and zero all the matrices we declared in the "matrices" member of class Computation (Except those corresponding to inputs; those will be set up when the user provides the input). The commands will be of type kAllocateMatrixZeroed, with one argument corresponding to the matrix index. Later, in the optimization phase, we will replace some of these commands with kAllocateMatrixUndefined, if we determine that zeroing the newly allocated matrix was not necessary.</p>
<h2><a class="anchor" id="dnn3_compile_compiler_forward"></a>
The forward computation</h2>
<p>The next stage of <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a218321cdd5637631bb8fc7b2eee008b3">AddCommands()</a> is the following: </p><pre class="fragment">  int32 num_steps = steps_.size();
  for (int32 step = 0; step &lt; num_steps; step++)
    DoForwardComputation(step, computation);
</pre><p> DoForwardComputation() adds the commands for the forward part of the computation. The code for this function, with a couple of checks removed, is below: </p><pre class="fragment">void Compiler::DoForwardComputation(int32 step,
                                    NnetComputation *computation) const {
  const StepInfo &amp;step_info = steps_[step];
  const NetworkNode &amp;node = nnet_.GetNode(step_info.node_index);
  switch (node.node_type) {
    case kInput: case kDimRange: break;  // Nothing to do.
    case kComponent:
      AddPropagateStep(step, computation);
      break;
    case kDescriptor:
      DoForwardComputationDescriptor(step, computation);
      break;
  }
}
</pre><h3><a class="anchor" id="dnn3_compile_compiler_forward_component"></a>
Forward computation for Components</h3>
<p>If the step is of type kComponent, setting up the forward computation is quite simple. The function AddPropagateStep() adds a single command of type kPropagate, of which the key part is this: </p><pre class="fragment">  NnetComputation::Command c(NnetComputation::kPropagate,
                             node.u.component_index,
                             step_info.precomputed_indexes_index,
                             input_submatrix_index,
                             output_submatrix_index);
  computation-&gt;commands.push_back(c);
</pre><p> This function is also responsible for adding the command to store the per-component stats (i.e. to call the function <a class="el" href="classkaldi_1_1nnet3_1_1Component.html#a304cec15e1a696a5af5f2f5daae7bc4f" title="This function may store stats on average activation values, and for some component types...">Component::StoreStats()</a>), if this is requested. The purpose of these stats is to detect nonlinearities that are oversaturated. The code is: </p><pre class="fragment">  if (request_.store_component_stats) {
    const Component *c = nnet_.GetComponent(node.u.component_index);
    if (c-&gt;Properties() &amp; kStoresStats) {
      NnetComputation::Command c(NnetComputation::kStoreStats,
                                 node.u.component_index,
                                 output_submatrix_index);
      computation-&gt;commands.push_back(c);
    }
  }
</pre><h3><a class="anchor" id="dnn3_compile_compiler_forward_descriptor"></a>
Forward computation for Descriptors (top-level)</h3>
<p>Setting up the forward computation for Descriptors is a little more complicated. The function call <code>DoForwardComputationDescriptor(step, computation)</code> calls the following code: </p><pre class="fragment">void Compiler::DoForwardComputationDescriptor(
    int32 step, NnetComputation *computation) const {
  int32 num_parts = steps_[step].value_parts.size();
  for (int32 part = 0; part &lt; num_parts; part++)
    DoForwardComputationSumDescriptor(step, part, computation);
}
</pre><p> DoForwardComputationSumDescriptor() is defined as follows: </p><pre class="fragment">void Compiler::DoForwardComputationSumDescriptor(
    int32 step, int32 part_index, NnetComputation *computation) const {
  const StepInfo &amp;step_info = steps_[step];
  std::vector&lt;std::vector&lt;std::pair&lt;int32, int32&gt; &gt; &gt; submat_locations_list;
  ComputeValueSubmatLocationsList(step_info.input_locations_list[part_index],
                                  &amp;submat_locations_list);
  int32 value_submatrix_index = step_info.value_parts[part_index];
  DoForwardComputationFromSubmatLocationsList(
      value_submatrix_index,
      submat_locations_list,
      computation);
}
</pre><p> The call to <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#aee3c7011e653ea46c0e2081c1eabdc7f">ComputeValueSubmatLocationsList()</a> turns the previously discussed input_locations_list in the standard location format with pairs (step-index, row-index) into submat-location format with pairs (submatrix-index, row-index). Stepping into DoForwardComputationFromSubmatLocationsList(), we see the following code: </p><pre class="fragment">void Compiler::DoForwardComputationFromSubmatLocationsList(
    int32 value_submatrix_index,
    const std::vector&lt;std::vector&lt;std::pair&lt;int32, int32&gt; &gt; &gt; &amp;submat_lists,
    NnetComputation *computation) const {
  std::vector&lt;std::vector&lt;std::pair&lt;int32, int32&gt; &gt; &gt; split_lists;
  SplitLocations(submat_lists, &amp;split_lists);
  for (int32 i = 0; i &lt; split_lists.size(); i++)
    DoForwardComputationFromSubmatLocations(
        value_submatrix_index, (i == 0),
        split_lists[i],
        computation);
}
</pre><h3><a class="anchor" id="dnn3_compile_compiler_split_locations"></a>
Forward computation for Descriptors (SplitLocations)</h3>
<p>The function <a class="el" href="namespacekaldi_1_1nnet3.html#a7c81548b4f8146cd3447b10d556978a8" title="The input to this function is a vector of lists of pairs, and this function splits it up into a list ...">SplitLocations()</a> is important. Its input and output is of the same type (<code>std::vector&lt;std::pair&lt;int32, int32&gt; &gt;</code>, but it performs a change of format. The input <code>submat_lists</code> is indexed by matrix-row and is then a list of input locations to be summed over. <a class="el" href="namespacekaldi_1_1nnet3.html#a7c81548b4f8146cd3447b10d556978a8" title="The input to this function is a vector of lists of pairs, and this function splits it up into a list ...">SplitLocations()</a> pads all those lists with (-1, -1) so they are all the same length and then turns the vector of lists into a list of vectors (<code>split_lists</code>). For example, if we had a matrix with 1000 rows and the input submat_lists were all of length not exceeding 2, the <a class="el" href="namespacekaldi_1_1nnet3.html#a7c81548b4f8146cd3447b10d556978a8" title="The input to this function is a vector of lists of pairs, and this function splits it up into a list ...">SplitLocations()</a> would output a vector of length 2, each element being a vector of length 1000; and there would be (-1, -1) pairs in one or both of those output lists, if not all of the input vectors had size exactly 2.</p>
<p>In fact, <a class="el" href="namespacekaldi_1_1nnet3.html#a7c81548b4f8146cd3447b10d556978a8" title="The input to this function is a vector of lists of pairs, and this function splits it up into a list ...">SplitLocations()</a> tries to be a bit clever about how it splits things up, to try to ensure that inputs from the same submatrix are allocated as much as possible to the same vector in the output. This will enable us to use slightly more efficient commands in the compiled computation. <a class="el" href="namespacekaldi_1_1nnet3.html#a7c81548b4f8146cd3447b10d556978a8" title="The input to this function is a vector of lists of pairs, and this function splits it up into a list ...">SplitLocations()</a> may end up outputting a slightly larger number of vectors in order to achieve this.</p>
<h3><a class="anchor" id="dnn3_compile_compiler_forward_submat"></a>
Forward computation with DoForwardComputationFromSubmatLocations</h3>
<p>After splitting up the submat-location lists using <a class="el" href="namespacekaldi_1_1nnet3.html#a7c81548b4f8146cd3447b10d556978a8" title="The input to this function is a vector of lists of pairs, and this function splits it up into a list ...">SplitLocations()</a>, we give each vector in the resulting list to DoForwardComputationFromSubmatLocations(). The main input to this function is a vector of submat-locations, i.e. a vector of pairs (submatrix-index, row-index), where the length of the vector corresponds to the number of matrix rows (or equivalently, the number of cindex_ids in the step). This function works out the appropriate command to use in the forward propagation, trying to figure out which one will be the most efficient. The code for this function is quite simple so we show it: </p><pre class="fragment">void Compiler::DoForwardComputationFromSubmatLocations(
    int32 value_submatrix_index,
    bool is_first_term_in_sum,
    const std::vector&lt;std::pair&lt;int32, int32&gt; &gt; &amp;submat_locations,
    NnetComputation *computation) const {

  int32 input_submatrix_index = -1;
  std::vector&lt;int32&gt; indexes;

  if (ConvertToIndexes(submat_locations, &amp;input_submatrix_index, &amp;indexes)) {
    DoForwardComputationFromIndexes(value_submatrix_index,
                                    input_submatrix_index,
                                    is_first_term_in_sum,
                                    indexes,
                                    computation);
    return;
  } else {
    // There are multiple source matrices.
    NnetComputation::CommandType ctype =
        (is_first_term_in_sum ?
         NnetComputation::kCopyRowsMulti : NnetComputation::kAddRowsMulti);
    int32 indexes_multi_index = computation-&gt;indexes_multi.size();
    computation-&gt;indexes_multi.push_back(submat_locations);
    computation-&gt;commands.push_back(
        NnetComputation::Command(ctype, value_submatrix_index,
                                 indexes_multi_index));
    return;
  }
}
</pre><p> The function <a class="el" href="namespacekaldi_1_1nnet3.html#ae99488174e8dde27f8f30d91d61c0cd2" title="If it is the case for some i &gt;= 0 that all the .first elements of &quot;location_vector&quot; are either i or -...">ConvertToIndexes()</a> is detecting for us the case where all inputs come from the same submatrix, and if so, converts the submat-locations vector to a single submatrix index a vector of row indexes, which will contain -1's corresponding to any (-1, -1) values in the input submat_locations. In this case we call DoForwardComputationFromIndexes(), which if possible creates a command for a simple matrix copy or add (commands kMatrixCopy and kMatrixAdd), and otherwise into a command of type kCopyRows or kAddRows, which will call the functions <a class="el" href="classkaldi_1_1CuMatrixBase.html#ab3c837bb106bfab035db4ea22906acef">CopyRows()</a> <a class="el" href="classkaldi_1_1CuMatrixBase.html#a62c46e6440ae6045cb2f0af43f26c1d5">AddRows()</a> of class <a class="el" href="classkaldi_1_1CuMatrix.html" title="This class represents a matrix that&#39;s stored on the GPU if we have one, and in memory if not...">CuMatrix</a>.</p>
<p>If there were multiple source sub-matrices, then we generate a command of type kCopyRowsMulti or kAddRowsMulti, calling the functions CopyRowsMulti() AddRowsMulti() of class <a class="el" href="classkaldi_1_1CuMatrix.html" title="This class represents a matrix that&#39;s stored on the GPU if we have one, and in memory if not...">CuMatrix</a>. These functions take pointer arguments, pointing to the row-address of the source data for each row of the destination matrix. We prefer not to call those functions, because to use them we transfer the addresses to the GPU card for each minibatch (we reallocate the matrices each time, so the addresses might change). This is a minor issue, though.</p>
<h3><a class="anchor" id="dnn3_compile_compiler_forward_end"></a>
Marking the end of the forward computation</h3>
<p>After we are finished setting up the commands for the forward computation, we mark that it's over. This is done as follows: </p><pre class="fragment">  computation-&gt;commands.push_back(
      NnetComputation::Command(NnetComputation::kNoOperationMarker));
</pre><p> The execution code will later detect this marker to know when the forward part of the computation ends and the backward part begins.</p>
<h2><a class="anchor" id="dnn3_compile_compiler_backward"></a>
The backward computation</h2>
<p>The backward computation is created in the following statements from <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a218321cdd5637631bb8fc7b2eee008b3">AddCommands()</a>: </p><pre class="fragment">  for (int32 step = num_steps - 1; step &gt;= 0; step--)
    if (deriv_needed[step])
      DoBackwardComputation(step, computation);
</pre><p> The code for DoBackwardComputation() mostly mirrors that of "DoForwardComputation()", so we won't go into it in detail. However, we would like to point out that DoBackwardComputationSubmatLocationsList() differs from DoForwardComputationSubmatLocationsList() in that it calls the function <a class="el" href="namespacekaldi_1_1nnet3.html#a230b979419515f453ee5c8f2bc87a4dd">SplitLocationsBackward()</a> instead of <a class="el" href="namespacekaldi_1_1nnet3.html#a7c81548b4f8146cd3447b10d556978a8" title="The input to this function is a vector of lists of pairs, and this function splits it up into a list ...">SplitLocations()</a>. The issue is that when splitting the submatrix-locations, we need to be a little more careful to ensure we generate valid commands. In the forward computation, if multiple locations of the matrix are copied (or added-to) from the same input location, it is not a problem. However, in the backward computation, this would be a problem because it could lead to different CUDA kernels attempting to update the same location at the same time. While there are solutions to this synchronization problem, they have a cost and we prefer to avoid the issue.</p>
<p>Our solution is essentially as follows, and see the documentation of <a class="el" href="namespacekaldi_1_1nnet3.html#a230b979419515f453ee5c8f2bc87a4dd" title="This function has the same interface as SplitLocations(); however, it ensures certain additional prop...">SplitLocationsBackward()</a> for more details. We first split the locations into separate vectors as for <a class="el" href="namespacekaldi_1_1nnet3.html#a7c81548b4f8146cd3447b10d556978a8" title="The input to this function is a vector of lists of pairs, and this function splits it up into a list ...">SplitLocations()</a>. Then we split further as needed in order to ensure that either one of the two following properties holds: that for each vector, either:</p><ul>
<li>All pairs (submatrix-index, row-index) in the vector are unique, except possibly the special pair (-1, -1) may be repeated</li>
<li>The .first values (submatrix-index) in the list are all the same, and the .second have a special property (see the function <a class="el" href="namespacekaldi_1_1nnet3.html#ae892457066e9b2ac1632188de1aa06f1" title="This function returns true if for each integer i != -1, all the indexes j at which indexes[j] == i ar...">HasContiguousProperty()</a>) that allows us to call <a class="el" href="classkaldi_1_1CuMatrixBase.html#ae4eb60ca0d96773b8e5b33df26d8595f" title="For each row r of this and for each column c, do (*this)(r, c) +=  src(j, c), where j ranges from ind...">CuMatrix::AddRowRanges()</a>. The property is that each unique row-index must appear only in a single contiguous run.</li>
</ul>
<h2><a class="anchor" id="dnn3_compile_compiler_deallocating"></a>
the matrices  Deallocating the matrices</h2>
<p>The last command of <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a218321cdd5637631bb8fc7b2eee008b3">AddCommands()</a> adds commands to deallocate the matrices: </p><pre class="fragment">  DeallocateMatrices(computation);
</pre><p> We add commands (kDeallocMatrix) to deallocate each of the matrices in the computation, except those that are outputs of the computation (including requested derivatives at the inputs).</p>
<h2><a class="anchor" id="dnn3_compile_compiler_debug"></a>
Adding debug information</h2>
<p><a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a218321cdd5637631bb8fc7b2eee008b3">AddCommands()</a> terminates, the last command remaining in the function <a class="el" href="classkaldi_1_1nnet3_1_1Compiler.html#a3ba7e6700716ba8e6dfb85784922001b">CreateComputation()</a> is to output the debug information, if requested: </p><pre class="fragment">  if (opts.output_debug_info)
    OutputDebugInfo(computation);
</pre><p> This information is intended mostly for diagnostics and to help users interpret the meaning of matrices in a compiler computation, and consists of the following: </p><pre class="fragment">  struct MatrixDebugInfo {
    bool is_deriv;  // true if this represents a derivative, not a value.
    int32 node_index;  // network-node index.
    std::vector&lt;Index&gt; indexes;
    MatrixDebugInfo(): is_deriv(false), node_index(-1) {}
  };
</pre><p> We won't go into further detail on this, since it's quite obvious what this function would do. We note that in the optimization phase, we sometimes merge matrices together as an optimization. In this case the associated debug_info will correspond to the debug information of one of the matrices that we merged.</p>
<h2><a class="anchor" id="dnn3_compile_compiler_shortcut"></a>
Shortcut compilation</h2>
<p>A feature available from Kaldi version 5.1 is 'shortcut' compilation (enabled by default). This is done only when the <a class="el" href="structkaldi_1_1nnet3_1_1ComputationRequest.html">ComputationRequest</a> has a suitably regular structure; this basically means that there are more than two different "n" indexes in the computation, they are numbered consecutively from zero, nd for each "n" index, the requested set of "t" and "x" indexes is the same and in a regular order. What the shortcut compilation does is reduce the computation request down to just two distinct "n" indexes (zero and one), compile the mini-request, and then expand the resulting compilation&ndash; basically, it extrapolates the compiled computation to what it would have been if the entire original computation request had been supplied. Shortcut compilation significantly cuts down compilation time.</p>
<ul>
<li>Up: <a class="el" href="dnn3.html">The "nnet3" setup</a></li>
<li>Previous: <a class="el" href="dnn3_code_data_types.html">Data types in the "nnet3" setup.</a></li>
<li>Next: <a class="el" href="dnn3_code_optimization.html">Optimization in the "nnet3" setup</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Kaldi</a></li><li class="navelem"><a class="el" href="dnn.html">Deep Neural Networks in Kaldi</a></li><li class="navelem"><a class="el" href="dnn3.html">The &quot;nnet3&quot; setup</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
